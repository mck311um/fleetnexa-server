/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `State` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library";
import type * as $Enums from "../enums.js";
import type * as Prisma from "../internal/prismaNamespace.js";

/**
 * Model State
 *
 */
export type StateModel =
	runtime.Types.Result.DefaultSelection<Prisma.$StatePayload>;

export type AggregateState = {
	_count: StateCountAggregateOutputType | null;
	_avg: StateAvgAggregateOutputType | null;
	_sum: StateSumAggregateOutputType | null;
	_min: StateMinAggregateOutputType | null;
	_max: StateMaxAggregateOutputType | null;
};

export type StateAvgAggregateOutputType = {
	geoNameId: number | null;
};

export type StateSumAggregateOutputType = {
	geoNameId: number | null;
};

export type StateMinAggregateOutputType = {
	id: string | null;
	countryId: string | null;
	state: string | null;
	geoNameId: number | null;
};

export type StateMaxAggregateOutputType = {
	id: string | null;
	countryId: string | null;
	state: string | null;
	geoNameId: number | null;
};

export type StateCountAggregateOutputType = {
	id: number;
	countryId: number;
	state: number;
	geoNameId: number;
	_all: number;
};

export type StateAvgAggregateInputType = {
	geoNameId?: true;
};

export type StateSumAggregateInputType = {
	geoNameId?: true;
};

export type StateMinAggregateInputType = {
	id?: true;
	countryId?: true;
	state?: true;
	geoNameId?: true;
};

export type StateMaxAggregateInputType = {
	id?: true;
	countryId?: true;
	state?: true;
	geoNameId?: true;
};

export type StateCountAggregateInputType = {
	id?: true;
	countryId?: true;
	state?: true;
	geoNameId?: true;
	_all?: true;
};

export type StateAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which State to aggregate.
	 */
	where?: Prisma.StateWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of States to fetch.
	 */
	orderBy?:
		| Prisma.StateOrderByWithRelationInput
		| Prisma.StateOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.StateWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` States from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` States.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned States
	 **/
	_count?: true | StateCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: StateAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: StateSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: StateMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: StateMaxAggregateInputType;
};

export type GetStateAggregateType<T extends StateAggregateArgs> = {
	[P in keyof T & keyof AggregateState]: P extends "_count" | "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateState[P]>
		: Prisma.GetScalarType<T[P], AggregateState[P]>;
};

export type StateGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.StateWhereInput;
	orderBy?:
		| Prisma.StateOrderByWithAggregationInput
		| Prisma.StateOrderByWithAggregationInput[];
	by: Prisma.StateScalarFieldEnum[] | Prisma.StateScalarFieldEnum;
	having?: Prisma.StateScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: StateCountAggregateInputType | true;
	_avg?: StateAvgAggregateInputType;
	_sum?: StateSumAggregateInputType;
	_min?: StateMinAggregateInputType;
	_max?: StateMaxAggregateInputType;
};

export type StateGroupByOutputType = {
	id: string;
	countryId: string;
	state: string;
	geoNameId: number | null;
	_count: StateCountAggregateOutputType | null;
	_avg: StateAvgAggregateOutputType | null;
	_sum: StateSumAggregateOutputType | null;
	_min: StateMinAggregateOutputType | null;
	_max: StateMaxAggregateOutputType | null;
};

type GetStateGroupByPayload<T extends StateGroupByArgs> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<StateGroupByOutputType, T["by"]> & {
			[P in keyof T & keyof StateGroupByOutputType]: P extends "_count"
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], StateGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], StateGroupByOutputType[P]>;
		}
	>
>;

export type StateWhereInput = {
	AND?: Prisma.StateWhereInput | Prisma.StateWhereInput[];
	OR?: Prisma.StateWhereInput[];
	NOT?: Prisma.StateWhereInput | Prisma.StateWhereInput[];
	id?: Prisma.StringFilter<"State"> | string;
	countryId?: Prisma.StringFilter<"State"> | string;
	state?: Prisma.StringFilter<"State"> | string;
	geoNameId?: Prisma.IntNullableFilter<"State"> | number | null;
	addresses?: Prisma.AddressListRelationFilter;
	customerAddresses?: Prisma.CustomerAddressListRelationFilter;
	presetLocations?: Prisma.PresetLocationListRelationFilter;
	country?: Prisma.XOR<
		Prisma.CountryScalarRelationFilter,
		Prisma.CountryWhereInput
	>;
	storefrontUser?: Prisma.StorefrontUserListRelationFilter;
	villages?: Prisma.VillageListRelationFilter;
};

export type StateOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	countryId?: Prisma.SortOrder;
	state?: Prisma.SortOrder;
	geoNameId?: Prisma.SortOrderInput | Prisma.SortOrder;
	addresses?: Prisma.AddressOrderByRelationAggregateInput;
	customerAddresses?: Prisma.CustomerAddressOrderByRelationAggregateInput;
	presetLocations?: Prisma.PresetLocationOrderByRelationAggregateInput;
	country?: Prisma.CountryOrderByWithRelationInput;
	storefrontUser?: Prisma.StorefrontUserOrderByRelationAggregateInput;
	villages?: Prisma.VillageOrderByRelationAggregateInput;
};

export type StateWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		geoNameId?: number;
		AND?: Prisma.StateWhereInput | Prisma.StateWhereInput[];
		OR?: Prisma.StateWhereInput[];
		NOT?: Prisma.StateWhereInput | Prisma.StateWhereInput[];
		countryId?: Prisma.StringFilter<"State"> | string;
		state?: Prisma.StringFilter<"State"> | string;
		addresses?: Prisma.AddressListRelationFilter;
		customerAddresses?: Prisma.CustomerAddressListRelationFilter;
		presetLocations?: Prisma.PresetLocationListRelationFilter;
		country?: Prisma.XOR<
			Prisma.CountryScalarRelationFilter,
			Prisma.CountryWhereInput
		>;
		storefrontUser?: Prisma.StorefrontUserListRelationFilter;
		villages?: Prisma.VillageListRelationFilter;
	},
	"id" | "geoNameId"
>;

export type StateOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	countryId?: Prisma.SortOrder;
	state?: Prisma.SortOrder;
	geoNameId?: Prisma.SortOrderInput | Prisma.SortOrder;
	_count?: Prisma.StateCountOrderByAggregateInput;
	_avg?: Prisma.StateAvgOrderByAggregateInput;
	_max?: Prisma.StateMaxOrderByAggregateInput;
	_min?: Prisma.StateMinOrderByAggregateInput;
	_sum?: Prisma.StateSumOrderByAggregateInput;
};

export type StateScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.StateScalarWhereWithAggregatesInput
		| Prisma.StateScalarWhereWithAggregatesInput[];
	OR?: Prisma.StateScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.StateScalarWhereWithAggregatesInput
		| Prisma.StateScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"State"> | string;
	countryId?: Prisma.StringWithAggregatesFilter<"State"> | string;
	state?: Prisma.StringWithAggregatesFilter<"State"> | string;
	geoNameId?: Prisma.IntNullableWithAggregatesFilter<"State"> | number | null;
};

export type StateCreateInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationCreateNestedManyWithoutStateInput;
	country: Prisma.CountryCreateNestedOneWithoutStatesInput;
	storefrontUser?: Prisma.StorefrontUserCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageCreateNestedManyWithoutStateInput;
};

export type StateUncheckedCreateInput = {
	id?: string;
	countryId: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressUncheckedCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationUncheckedCreateNestedManyWithoutStateInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageUncheckedCreateNestedManyWithoutStateInput;
};

export type StateUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUpdateManyWithoutStateNestedInput;
	country?: Prisma.CountryUpdateOneRequiredWithoutStatesNestedInput;
	storefrontUser?: Prisma.StorefrontUserUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUpdateManyWithoutStateNestedInput;
};

export type StateUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	countryId?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUncheckedUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUncheckedUpdateManyWithoutStateNestedInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUncheckedUpdateManyWithoutStateNestedInput;
};

export type StateCreateManyInput = {
	id?: string;
	countryId: string;
	state: string;
	geoNameId?: number | null;
};

export type StateUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
};

export type StateUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	countryId?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
};

export type StateListRelationFilter = {
	every?: Prisma.StateWhereInput;
	some?: Prisma.StateWhereInput;
	none?: Prisma.StateWhereInput;
};

export type StateOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type StateCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	countryId?: Prisma.SortOrder;
	state?: Prisma.SortOrder;
	geoNameId?: Prisma.SortOrder;
};

export type StateAvgOrderByAggregateInput = {
	geoNameId?: Prisma.SortOrder;
};

export type StateMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	countryId?: Prisma.SortOrder;
	state?: Prisma.SortOrder;
	geoNameId?: Prisma.SortOrder;
};

export type StateMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	countryId?: Prisma.SortOrder;
	state?: Prisma.SortOrder;
	geoNameId?: Prisma.SortOrder;
};

export type StateSumOrderByAggregateInput = {
	geoNameId?: Prisma.SortOrder;
};

export type StateScalarRelationFilter = {
	is?: Prisma.StateWhereInput;
	isNot?: Prisma.StateWhereInput;
};

export type StateNullableScalarRelationFilter = {
	is?: Prisma.StateWhereInput | null;
	isNot?: Prisma.StateWhereInput | null;
};

export type StateCreateNestedManyWithoutCountryInput = {
	create?:
		| Prisma.XOR<
				Prisma.StateCreateWithoutCountryInput,
				Prisma.StateUncheckedCreateWithoutCountryInput
		  >
		| Prisma.StateCreateWithoutCountryInput[]
		| Prisma.StateUncheckedCreateWithoutCountryInput[];
	connectOrCreate?:
		| Prisma.StateCreateOrConnectWithoutCountryInput
		| Prisma.StateCreateOrConnectWithoutCountryInput[];
	createMany?: Prisma.StateCreateManyCountryInputEnvelope;
	connect?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
};

export type StateUncheckedCreateNestedManyWithoutCountryInput = {
	create?:
		| Prisma.XOR<
				Prisma.StateCreateWithoutCountryInput,
				Prisma.StateUncheckedCreateWithoutCountryInput
		  >
		| Prisma.StateCreateWithoutCountryInput[]
		| Prisma.StateUncheckedCreateWithoutCountryInput[];
	connectOrCreate?:
		| Prisma.StateCreateOrConnectWithoutCountryInput
		| Prisma.StateCreateOrConnectWithoutCountryInput[];
	createMany?: Prisma.StateCreateManyCountryInputEnvelope;
	connect?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
};

export type StateUpdateManyWithoutCountryNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.StateCreateWithoutCountryInput,
				Prisma.StateUncheckedCreateWithoutCountryInput
		  >
		| Prisma.StateCreateWithoutCountryInput[]
		| Prisma.StateUncheckedCreateWithoutCountryInput[];
	connectOrCreate?:
		| Prisma.StateCreateOrConnectWithoutCountryInput
		| Prisma.StateCreateOrConnectWithoutCountryInput[];
	upsert?:
		| Prisma.StateUpsertWithWhereUniqueWithoutCountryInput
		| Prisma.StateUpsertWithWhereUniqueWithoutCountryInput[];
	createMany?: Prisma.StateCreateManyCountryInputEnvelope;
	set?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
	disconnect?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
	delete?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
	connect?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
	update?:
		| Prisma.StateUpdateWithWhereUniqueWithoutCountryInput
		| Prisma.StateUpdateWithWhereUniqueWithoutCountryInput[];
	updateMany?:
		| Prisma.StateUpdateManyWithWhereWithoutCountryInput
		| Prisma.StateUpdateManyWithWhereWithoutCountryInput[];
	deleteMany?: Prisma.StateScalarWhereInput | Prisma.StateScalarWhereInput[];
};

export type StateUncheckedUpdateManyWithoutCountryNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.StateCreateWithoutCountryInput,
				Prisma.StateUncheckedCreateWithoutCountryInput
		  >
		| Prisma.StateCreateWithoutCountryInput[]
		| Prisma.StateUncheckedCreateWithoutCountryInput[];
	connectOrCreate?:
		| Prisma.StateCreateOrConnectWithoutCountryInput
		| Prisma.StateCreateOrConnectWithoutCountryInput[];
	upsert?:
		| Prisma.StateUpsertWithWhereUniqueWithoutCountryInput
		| Prisma.StateUpsertWithWhereUniqueWithoutCountryInput[];
	createMany?: Prisma.StateCreateManyCountryInputEnvelope;
	set?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
	disconnect?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
	delete?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
	connect?: Prisma.StateWhereUniqueInput | Prisma.StateWhereUniqueInput[];
	update?:
		| Prisma.StateUpdateWithWhereUniqueWithoutCountryInput
		| Prisma.StateUpdateWithWhereUniqueWithoutCountryInput[];
	updateMany?:
		| Prisma.StateUpdateManyWithWhereWithoutCountryInput
		| Prisma.StateUpdateManyWithWhereWithoutCountryInput[];
	deleteMany?: Prisma.StateScalarWhereInput | Prisma.StateScalarWhereInput[];
};

export type NullableIntFieldUpdateOperationsInput = {
	set?: number | null;
	increment?: number;
	decrement?: number;
	multiply?: number;
	divide?: number;
};

export type StateCreateNestedOneWithoutVillagesInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutVillagesInput,
		Prisma.StateUncheckedCreateWithoutVillagesInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutVillagesInput;
	connect?: Prisma.StateWhereUniqueInput;
};

export type StateUpdateOneRequiredWithoutVillagesNestedInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutVillagesInput,
		Prisma.StateUncheckedCreateWithoutVillagesInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutVillagesInput;
	upsert?: Prisma.StateUpsertWithoutVillagesInput;
	connect?: Prisma.StateWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.StateUpdateToOneWithWhereWithoutVillagesInput,
			Prisma.StateUpdateWithoutVillagesInput
		>,
		Prisma.StateUncheckedUpdateWithoutVillagesInput
	>;
};

export type StateCreateNestedOneWithoutPresetLocationsInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutPresetLocationsInput,
		Prisma.StateUncheckedCreateWithoutPresetLocationsInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutPresetLocationsInput;
	connect?: Prisma.StateWhereUniqueInput;
};

export type StateUpdateOneRequiredWithoutPresetLocationsNestedInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutPresetLocationsInput,
		Prisma.StateUncheckedCreateWithoutPresetLocationsInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutPresetLocationsInput;
	upsert?: Prisma.StateUpsertWithoutPresetLocationsInput;
	connect?: Prisma.StateWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.StateUpdateToOneWithWhereWithoutPresetLocationsInput,
			Prisma.StateUpdateWithoutPresetLocationsInput
		>,
		Prisma.StateUncheckedUpdateWithoutPresetLocationsInput
	>;
};

export type StateCreateNestedOneWithoutCustomerAddressesInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutCustomerAddressesInput,
		Prisma.StateUncheckedCreateWithoutCustomerAddressesInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutCustomerAddressesInput;
	connect?: Prisma.StateWhereUniqueInput;
};

export type StateUpdateOneWithoutCustomerAddressesNestedInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutCustomerAddressesInput,
		Prisma.StateUncheckedCreateWithoutCustomerAddressesInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutCustomerAddressesInput;
	upsert?: Prisma.StateUpsertWithoutCustomerAddressesInput;
	disconnect?: Prisma.StateWhereInput | boolean;
	delete?: Prisma.StateWhereInput | boolean;
	connect?: Prisma.StateWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.StateUpdateToOneWithWhereWithoutCustomerAddressesInput,
			Prisma.StateUpdateWithoutCustomerAddressesInput
		>,
		Prisma.StateUncheckedUpdateWithoutCustomerAddressesInput
	>;
};

export type StateCreateNestedOneWithoutAddressesInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutAddressesInput,
		Prisma.StateUncheckedCreateWithoutAddressesInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutAddressesInput;
	connect?: Prisma.StateWhereUniqueInput;
};

export type StateUpdateOneWithoutAddressesNestedInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutAddressesInput,
		Prisma.StateUncheckedCreateWithoutAddressesInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutAddressesInput;
	upsert?: Prisma.StateUpsertWithoutAddressesInput;
	disconnect?: Prisma.StateWhereInput | boolean;
	delete?: Prisma.StateWhereInput | boolean;
	connect?: Prisma.StateWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.StateUpdateToOneWithWhereWithoutAddressesInput,
			Prisma.StateUpdateWithoutAddressesInput
		>,
		Prisma.StateUncheckedUpdateWithoutAddressesInput
	>;
};

export type StateCreateNestedOneWithoutStorefrontUserInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutStorefrontUserInput,
		Prisma.StateUncheckedCreateWithoutStorefrontUserInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutStorefrontUserInput;
	connect?: Prisma.StateWhereUniqueInput;
};

export type StateUpdateOneWithoutStorefrontUserNestedInput = {
	create?: Prisma.XOR<
		Prisma.StateCreateWithoutStorefrontUserInput,
		Prisma.StateUncheckedCreateWithoutStorefrontUserInput
	>;
	connectOrCreate?: Prisma.StateCreateOrConnectWithoutStorefrontUserInput;
	upsert?: Prisma.StateUpsertWithoutStorefrontUserInput;
	disconnect?: Prisma.StateWhereInput | boolean;
	delete?: Prisma.StateWhereInput | boolean;
	connect?: Prisma.StateWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.StateUpdateToOneWithWhereWithoutStorefrontUserInput,
			Prisma.StateUpdateWithoutStorefrontUserInput
		>,
		Prisma.StateUncheckedUpdateWithoutStorefrontUserInput
	>;
};

export type StateCreateWithoutCountryInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationCreateNestedManyWithoutStateInput;
	storefrontUser?: Prisma.StorefrontUserCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageCreateNestedManyWithoutStateInput;
};

export type StateUncheckedCreateWithoutCountryInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressUncheckedCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationUncheckedCreateNestedManyWithoutStateInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageUncheckedCreateNestedManyWithoutStateInput;
};

export type StateCreateOrConnectWithoutCountryInput = {
	where: Prisma.StateWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutCountryInput,
		Prisma.StateUncheckedCreateWithoutCountryInput
	>;
};

export type StateCreateManyCountryInputEnvelope = {
	data:
		| Prisma.StateCreateManyCountryInput
		| Prisma.StateCreateManyCountryInput[];
	skipDuplicates?: boolean;
};

export type StateUpsertWithWhereUniqueWithoutCountryInput = {
	where: Prisma.StateWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.StateUpdateWithoutCountryInput,
		Prisma.StateUncheckedUpdateWithoutCountryInput
	>;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutCountryInput,
		Prisma.StateUncheckedCreateWithoutCountryInput
	>;
};

export type StateUpdateWithWhereUniqueWithoutCountryInput = {
	where: Prisma.StateWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.StateUpdateWithoutCountryInput,
		Prisma.StateUncheckedUpdateWithoutCountryInput
	>;
};

export type StateUpdateManyWithWhereWithoutCountryInput = {
	where: Prisma.StateScalarWhereInput;
	data: Prisma.XOR<
		Prisma.StateUpdateManyMutationInput,
		Prisma.StateUncheckedUpdateManyWithoutCountryInput
	>;
};

export type StateScalarWhereInput = {
	AND?: Prisma.StateScalarWhereInput | Prisma.StateScalarWhereInput[];
	OR?: Prisma.StateScalarWhereInput[];
	NOT?: Prisma.StateScalarWhereInput | Prisma.StateScalarWhereInput[];
	id?: Prisma.StringFilter<"State"> | string;
	countryId?: Prisma.StringFilter<"State"> | string;
	state?: Prisma.StringFilter<"State"> | string;
	geoNameId?: Prisma.IntNullableFilter<"State"> | number | null;
};

export type StateCreateWithoutVillagesInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationCreateNestedManyWithoutStateInput;
	country: Prisma.CountryCreateNestedOneWithoutStatesInput;
	storefrontUser?: Prisma.StorefrontUserCreateNestedManyWithoutStateInput;
};

export type StateUncheckedCreateWithoutVillagesInput = {
	id?: string;
	countryId: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressUncheckedCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationUncheckedCreateNestedManyWithoutStateInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedCreateNestedManyWithoutStateInput;
};

export type StateCreateOrConnectWithoutVillagesInput = {
	where: Prisma.StateWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutVillagesInput,
		Prisma.StateUncheckedCreateWithoutVillagesInput
	>;
};

export type StateUpsertWithoutVillagesInput = {
	update: Prisma.XOR<
		Prisma.StateUpdateWithoutVillagesInput,
		Prisma.StateUncheckedUpdateWithoutVillagesInput
	>;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutVillagesInput,
		Prisma.StateUncheckedCreateWithoutVillagesInput
	>;
	where?: Prisma.StateWhereInput;
};

export type StateUpdateToOneWithWhereWithoutVillagesInput = {
	where?: Prisma.StateWhereInput;
	data: Prisma.XOR<
		Prisma.StateUpdateWithoutVillagesInput,
		Prisma.StateUncheckedUpdateWithoutVillagesInput
	>;
};

export type StateUpdateWithoutVillagesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUpdateManyWithoutStateNestedInput;
	country?: Prisma.CountryUpdateOneRequiredWithoutStatesNestedInput;
	storefrontUser?: Prisma.StorefrontUserUpdateManyWithoutStateNestedInput;
};

export type StateUncheckedUpdateWithoutVillagesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	countryId?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUncheckedUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUncheckedUpdateManyWithoutStateNestedInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedUpdateManyWithoutStateNestedInput;
};

export type StateCreateWithoutPresetLocationsInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressCreateNestedManyWithoutStateInput;
	country: Prisma.CountryCreateNestedOneWithoutStatesInput;
	storefrontUser?: Prisma.StorefrontUserCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageCreateNestedManyWithoutStateInput;
};

export type StateUncheckedCreateWithoutPresetLocationsInput = {
	id?: string;
	countryId: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressUncheckedCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedCreateNestedManyWithoutStateInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageUncheckedCreateNestedManyWithoutStateInput;
};

export type StateCreateOrConnectWithoutPresetLocationsInput = {
	where: Prisma.StateWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutPresetLocationsInput,
		Prisma.StateUncheckedCreateWithoutPresetLocationsInput
	>;
};

export type StateUpsertWithoutPresetLocationsInput = {
	update: Prisma.XOR<
		Prisma.StateUpdateWithoutPresetLocationsInput,
		Prisma.StateUncheckedUpdateWithoutPresetLocationsInput
	>;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutPresetLocationsInput,
		Prisma.StateUncheckedCreateWithoutPresetLocationsInput
	>;
	where?: Prisma.StateWhereInput;
};

export type StateUpdateToOneWithWhereWithoutPresetLocationsInput = {
	where?: Prisma.StateWhereInput;
	data: Prisma.XOR<
		Prisma.StateUpdateWithoutPresetLocationsInput,
		Prisma.StateUncheckedUpdateWithoutPresetLocationsInput
	>;
};

export type StateUpdateWithoutPresetLocationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUpdateManyWithoutStateNestedInput;
	country?: Prisma.CountryUpdateOneRequiredWithoutStatesNestedInput;
	storefrontUser?: Prisma.StorefrontUserUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUpdateManyWithoutStateNestedInput;
};

export type StateUncheckedUpdateWithoutPresetLocationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	countryId?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUncheckedUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedUpdateManyWithoutStateNestedInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUncheckedUpdateManyWithoutStateNestedInput;
};

export type StateCreateWithoutCustomerAddressesInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationCreateNestedManyWithoutStateInput;
	country: Prisma.CountryCreateNestedOneWithoutStatesInput;
	storefrontUser?: Prisma.StorefrontUserCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageCreateNestedManyWithoutStateInput;
};

export type StateUncheckedCreateWithoutCustomerAddressesInput = {
	id?: string;
	countryId: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressUncheckedCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationUncheckedCreateNestedManyWithoutStateInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageUncheckedCreateNestedManyWithoutStateInput;
};

export type StateCreateOrConnectWithoutCustomerAddressesInput = {
	where: Prisma.StateWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutCustomerAddressesInput,
		Prisma.StateUncheckedCreateWithoutCustomerAddressesInput
	>;
};

export type StateUpsertWithoutCustomerAddressesInput = {
	update: Prisma.XOR<
		Prisma.StateUpdateWithoutCustomerAddressesInput,
		Prisma.StateUncheckedUpdateWithoutCustomerAddressesInput
	>;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutCustomerAddressesInput,
		Prisma.StateUncheckedCreateWithoutCustomerAddressesInput
	>;
	where?: Prisma.StateWhereInput;
};

export type StateUpdateToOneWithWhereWithoutCustomerAddressesInput = {
	where?: Prisma.StateWhereInput;
	data: Prisma.XOR<
		Prisma.StateUpdateWithoutCustomerAddressesInput,
		Prisma.StateUncheckedUpdateWithoutCustomerAddressesInput
	>;
};

export type StateUpdateWithoutCustomerAddressesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUpdateManyWithoutStateNestedInput;
	country?: Prisma.CountryUpdateOneRequiredWithoutStatesNestedInput;
	storefrontUser?: Prisma.StorefrontUserUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUpdateManyWithoutStateNestedInput;
};

export type StateUncheckedUpdateWithoutCustomerAddressesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	countryId?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUncheckedUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUncheckedUpdateManyWithoutStateNestedInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUncheckedUpdateManyWithoutStateNestedInput;
};

export type StateCreateWithoutAddressesInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
	customerAddresses?: Prisma.CustomerAddressCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationCreateNestedManyWithoutStateInput;
	country: Prisma.CountryCreateNestedOneWithoutStatesInput;
	storefrontUser?: Prisma.StorefrontUserCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageCreateNestedManyWithoutStateInput;
};

export type StateUncheckedCreateWithoutAddressesInput = {
	id?: string;
	countryId: string;
	state: string;
	geoNameId?: number | null;
	customerAddresses?: Prisma.CustomerAddressUncheckedCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationUncheckedCreateNestedManyWithoutStateInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageUncheckedCreateNestedManyWithoutStateInput;
};

export type StateCreateOrConnectWithoutAddressesInput = {
	where: Prisma.StateWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutAddressesInput,
		Prisma.StateUncheckedCreateWithoutAddressesInput
	>;
};

export type StateUpsertWithoutAddressesInput = {
	update: Prisma.XOR<
		Prisma.StateUpdateWithoutAddressesInput,
		Prisma.StateUncheckedUpdateWithoutAddressesInput
	>;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutAddressesInput,
		Prisma.StateUncheckedCreateWithoutAddressesInput
	>;
	where?: Prisma.StateWhereInput;
};

export type StateUpdateToOneWithWhereWithoutAddressesInput = {
	where?: Prisma.StateWhereInput;
	data: Prisma.XOR<
		Prisma.StateUpdateWithoutAddressesInput,
		Prisma.StateUncheckedUpdateWithoutAddressesInput
	>;
};

export type StateUpdateWithoutAddressesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	customerAddresses?: Prisma.CustomerAddressUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUpdateManyWithoutStateNestedInput;
	country?: Prisma.CountryUpdateOneRequiredWithoutStatesNestedInput;
	storefrontUser?: Prisma.StorefrontUserUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUpdateManyWithoutStateNestedInput;
};

export type StateUncheckedUpdateWithoutAddressesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	countryId?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	customerAddresses?: Prisma.CustomerAddressUncheckedUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUncheckedUpdateManyWithoutStateNestedInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUncheckedUpdateManyWithoutStateNestedInput;
};

export type StateCreateWithoutStorefrontUserInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationCreateNestedManyWithoutStateInput;
	country: Prisma.CountryCreateNestedOneWithoutStatesInput;
	villages?: Prisma.VillageCreateNestedManyWithoutStateInput;
};

export type StateUncheckedCreateWithoutStorefrontUserInput = {
	id?: string;
	countryId: string;
	state: string;
	geoNameId?: number | null;
	addresses?: Prisma.AddressUncheckedCreateNestedManyWithoutStateInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedCreateNestedManyWithoutStateInput;
	presetLocations?: Prisma.PresetLocationUncheckedCreateNestedManyWithoutStateInput;
	villages?: Prisma.VillageUncheckedCreateNestedManyWithoutStateInput;
};

export type StateCreateOrConnectWithoutStorefrontUserInput = {
	where: Prisma.StateWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutStorefrontUserInput,
		Prisma.StateUncheckedCreateWithoutStorefrontUserInput
	>;
};

export type StateUpsertWithoutStorefrontUserInput = {
	update: Prisma.XOR<
		Prisma.StateUpdateWithoutStorefrontUserInput,
		Prisma.StateUncheckedUpdateWithoutStorefrontUserInput
	>;
	create: Prisma.XOR<
		Prisma.StateCreateWithoutStorefrontUserInput,
		Prisma.StateUncheckedCreateWithoutStorefrontUserInput
	>;
	where?: Prisma.StateWhereInput;
};

export type StateUpdateToOneWithWhereWithoutStorefrontUserInput = {
	where?: Prisma.StateWhereInput;
	data: Prisma.XOR<
		Prisma.StateUpdateWithoutStorefrontUserInput,
		Prisma.StateUncheckedUpdateWithoutStorefrontUserInput
	>;
};

export type StateUpdateWithoutStorefrontUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUpdateManyWithoutStateNestedInput;
	country?: Prisma.CountryUpdateOneRequiredWithoutStatesNestedInput;
	villages?: Prisma.VillageUpdateManyWithoutStateNestedInput;
};

export type StateUncheckedUpdateWithoutStorefrontUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	countryId?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUncheckedUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUncheckedUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUncheckedUpdateManyWithoutStateNestedInput;
};

export type StateCreateManyCountryInput = {
	id?: string;
	state: string;
	geoNameId?: number | null;
};

export type StateUpdateWithoutCountryInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUpdateManyWithoutStateNestedInput;
	storefrontUser?: Prisma.StorefrontUserUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUpdateManyWithoutStateNestedInput;
};

export type StateUncheckedUpdateWithoutCountryInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	addresses?: Prisma.AddressUncheckedUpdateManyWithoutStateNestedInput;
	customerAddresses?: Prisma.CustomerAddressUncheckedUpdateManyWithoutStateNestedInput;
	presetLocations?: Prisma.PresetLocationUncheckedUpdateManyWithoutStateNestedInput;
	storefrontUser?: Prisma.StorefrontUserUncheckedUpdateManyWithoutStateNestedInput;
	villages?: Prisma.VillageUncheckedUpdateManyWithoutStateNestedInput;
};

export type StateUncheckedUpdateManyWithoutCountryInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	state?: Prisma.StringFieldUpdateOperationsInput | string;
	geoNameId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
};

/**
 * Count Type StateCountOutputType
 */

export type StateCountOutputType = {
	addresses: number;
	customerAddresses: number;
	presetLocations: number;
	storefrontUser: number;
	villages: number;
};

export type StateCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	addresses?: boolean | StateCountOutputTypeCountAddressesArgs;
	customerAddresses?: boolean | StateCountOutputTypeCountCustomerAddressesArgs;
	presetLocations?: boolean | StateCountOutputTypeCountPresetLocationsArgs;
	storefrontUser?: boolean | StateCountOutputTypeCountStorefrontUserArgs;
	villages?: boolean | StateCountOutputTypeCountVillagesArgs;
};

/**
 * StateCountOutputType without action
 */
export type StateCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the StateCountOutputType
	 */
	select?: Prisma.StateCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * StateCountOutputType without action
 */
export type StateCountOutputTypeCountAddressesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.AddressWhereInput;
};

/**
 * StateCountOutputType without action
 */
export type StateCountOutputTypeCountCustomerAddressesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.CustomerAddressWhereInput;
};

/**
 * StateCountOutputType without action
 */
export type StateCountOutputTypeCountPresetLocationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.PresetLocationWhereInput;
};

/**
 * StateCountOutputType without action
 */
export type StateCountOutputTypeCountStorefrontUserArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.StorefrontUserWhereInput;
};

/**
 * StateCountOutputType without action
 */
export type StateCountOutputTypeCountVillagesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.VillageWhereInput;
};

export type StateSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		countryId?: boolean;
		state?: boolean;
		geoNameId?: boolean;
		addresses?: boolean | Prisma.State$addressesArgs<ExtArgs>;
		customerAddresses?: boolean | Prisma.State$customerAddressesArgs<ExtArgs>;
		presetLocations?: boolean | Prisma.State$presetLocationsArgs<ExtArgs>;
		country?: boolean | Prisma.CountryDefaultArgs<ExtArgs>;
		storefrontUser?: boolean | Prisma.State$storefrontUserArgs<ExtArgs>;
		villages?: boolean | Prisma.State$villagesArgs<ExtArgs>;
		_count?: boolean | Prisma.StateCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["state"]
>;

export type StateSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		countryId?: boolean;
		state?: boolean;
		geoNameId?: boolean;
		country?: boolean | Prisma.CountryDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["state"]
>;

export type StateSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		countryId?: boolean;
		state?: boolean;
		geoNameId?: boolean;
		country?: boolean | Prisma.CountryDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["state"]
>;

export type StateSelectScalar = {
	id?: boolean;
	countryId?: boolean;
	state?: boolean;
	geoNameId?: boolean;
};

export type StateOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	"id" | "countryId" | "state" | "geoNameId",
	ExtArgs["result"]["state"]
>;
export type StateInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	addresses?: boolean | Prisma.State$addressesArgs<ExtArgs>;
	customerAddresses?: boolean | Prisma.State$customerAddressesArgs<ExtArgs>;
	presetLocations?: boolean | Prisma.State$presetLocationsArgs<ExtArgs>;
	country?: boolean | Prisma.CountryDefaultArgs<ExtArgs>;
	storefrontUser?: boolean | Prisma.State$storefrontUserArgs<ExtArgs>;
	villages?: boolean | Prisma.State$villagesArgs<ExtArgs>;
	_count?: boolean | Prisma.StateCountOutputTypeDefaultArgs<ExtArgs>;
};
export type StateIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	country?: boolean | Prisma.CountryDefaultArgs<ExtArgs>;
};
export type StateIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	country?: boolean | Prisma.CountryDefaultArgs<ExtArgs>;
};

export type $StatePayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "State";
	objects: {
		addresses: Prisma.$AddressPayload<ExtArgs>[];
		customerAddresses: Prisma.$CustomerAddressPayload<ExtArgs>[];
		presetLocations: Prisma.$PresetLocationPayload<ExtArgs>[];
		country: Prisma.$CountryPayload<ExtArgs>;
		storefrontUser: Prisma.$StorefrontUserPayload<ExtArgs>[];
		villages: Prisma.$VillagePayload<ExtArgs>[];
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			countryId: string;
			state: string;
			geoNameId: number | null;
		},
		ExtArgs["result"]["state"]
	>;
	composites: {};
};

export type StateGetPayload<
	S extends boolean | null | undefined | StateDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$StatePayload, S>;

export type StateCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<StateFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
	select?: StateCountAggregateInputType | true;
};

export interface StateDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["State"];
		meta: { name: "State" };
	};
	/**
	 * Find zero or one State that matches the filter.
	 * @param {StateFindUniqueArgs} args - Arguments to find a State
	 * @example
	 * // Get one State
	 * const state = await prisma.state.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends StateFindUniqueArgs>(
		args: Prisma.SelectSubset<T, StateFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__StateClient<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one State that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {StateFindUniqueOrThrowArgs} args - Arguments to find a State
	 * @example
	 * // Get one State
	 * const state = await prisma.state.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends StateFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, StateFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__StateClient<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first State that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {StateFindFirstArgs} args - Arguments to find a State
	 * @example
	 * // Get one State
	 * const state = await prisma.state.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends StateFindFirstArgs>(
		args?: Prisma.SelectSubset<T, StateFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__StateClient<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first State that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {StateFindFirstOrThrowArgs} args - Arguments to find a State
	 * @example
	 * // Get one State
	 * const state = await prisma.state.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends StateFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, StateFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__StateClient<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more States that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {StateFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all States
	 * const states = await prisma.state.findMany()
	 *
	 * // Get first 10 States
	 * const states = await prisma.state.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const stateWithIdOnly = await prisma.state.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends StateFindManyArgs>(
		args?: Prisma.SelectSubset<T, StateFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a State.
	 * @param {StateCreateArgs} args - Arguments to create a State.
	 * @example
	 * // Create one State
	 * const State = await prisma.state.create({
	 *   data: {
	 *     // ... data to create a State
	 *   }
	 * })
	 *
	 */
	create<T extends StateCreateArgs>(
		args: Prisma.SelectSubset<T, StateCreateArgs<ExtArgs>>,
	): Prisma.Prisma__StateClient<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many States.
	 * @param {StateCreateManyArgs} args - Arguments to create many States.
	 * @example
	 * // Create many States
	 * const state = await prisma.state.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends StateCreateManyArgs>(
		args?: Prisma.SelectSubset<T, StateCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many States and returns the data saved in the database.
	 * @param {StateCreateManyAndReturnArgs} args - Arguments to create many States.
	 * @example
	 * // Create many States
	 * const state = await prisma.state.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many States and only return the `id`
	 * const stateWithIdOnly = await prisma.state.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends StateCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, StateCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a State.
	 * @param {StateDeleteArgs} args - Arguments to delete one State.
	 * @example
	 * // Delete one State
	 * const State = await prisma.state.delete({
	 *   where: {
	 *     // ... filter to delete one State
	 *   }
	 * })
	 *
	 */
	delete<T extends StateDeleteArgs>(
		args: Prisma.SelectSubset<T, StateDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__StateClient<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one State.
	 * @param {StateUpdateArgs} args - Arguments to update one State.
	 * @example
	 * // Update one State
	 * const state = await prisma.state.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends StateUpdateArgs>(
		args: Prisma.SelectSubset<T, StateUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__StateClient<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more States.
	 * @param {StateDeleteManyArgs} args - Arguments to filter States to delete.
	 * @example
	 * // Delete a few States
	 * const { count } = await prisma.state.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends StateDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, StateDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more States.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {StateUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many States
	 * const state = await prisma.state.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends StateUpdateManyArgs>(
		args: Prisma.SelectSubset<T, StateUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more States and returns the data updated in the database.
	 * @param {StateUpdateManyAndReturnArgs} args - Arguments to update many States.
	 * @example
	 * // Update many States
	 * const state = await prisma.state.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more States and only return the `id`
	 * const stateWithIdOnly = await prisma.state.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends StateUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, StateUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one State.
	 * @param {StateUpsertArgs} args - Arguments to update or create a State.
	 * @example
	 * // Update or create a State
	 * const state = await prisma.state.upsert({
	 *   create: {
	 *     // ... data to create a State
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the State we want to update
	 *   }
	 * })
	 */
	upsert<T extends StateUpsertArgs>(
		args: Prisma.SelectSubset<T, StateUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__StateClient<
		runtime.Types.Result.GetResult<
			Prisma.$StatePayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of States.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {StateCountArgs} args - Arguments to filter States to count.
	 * @example
	 * // Count the number of States
	 * const count = await prisma.state.count({
	 *   where: {
	 *     // ... the filter for the States we want to count
	 *   }
	 * })
	 **/
	count<T extends StateCountArgs>(
		args?: Prisma.Subset<T, StateCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<T["select"], StateCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a State.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {StateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends StateAggregateArgs>(
		args: Prisma.Subset<T, StateAggregateArgs>,
	): Prisma.PrismaPromise<GetStateAggregateType<T>>;

	/**
	 * Group by State.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {StateGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends StateGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: StateGroupByArgs["orderBy"] }
			: { orderBy?: StateGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, StateGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetStateGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the State model
	 */
	readonly fields: StateFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for State.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__StateClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	addresses<T extends Prisma.State$addressesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.State$addressesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$AddressPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	customerAddresses<T extends Prisma.State$customerAddressesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.State$customerAddressesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$CustomerAddressPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	presetLocations<T extends Prisma.State$presetLocationsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.State$presetLocationsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$PresetLocationPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	country<T extends Prisma.CountryDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.CountryDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__CountryClient<
		| runtime.Types.Result.GetResult<
				Prisma.$CountryPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	storefrontUser<T extends Prisma.State$storefrontUserArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.State$storefrontUserArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$StorefrontUserPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	villages<T extends Prisma.State$villagesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.State$villagesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$VillagePayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the State model
 */
export interface StateFieldRefs {
	readonly id: Prisma.FieldRef<"State", "String">;
	readonly countryId: Prisma.FieldRef<"State", "String">;
	readonly state: Prisma.FieldRef<"State", "String">;
	readonly geoNameId: Prisma.FieldRef<"State", "Int">;
}

// Custom InputTypes
/**
 * State findUnique
 */
export type StateFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * Filter, which State to fetch.
	 */
	where: Prisma.StateWhereUniqueInput;
};

/**
 * State findUniqueOrThrow
 */
export type StateFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * Filter, which State to fetch.
	 */
	where: Prisma.StateWhereUniqueInput;
};

/**
 * State findFirst
 */
export type StateFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * Filter, which State to fetch.
	 */
	where?: Prisma.StateWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of States to fetch.
	 */
	orderBy?:
		| Prisma.StateOrderByWithRelationInput
		| Prisma.StateOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for States.
	 */
	cursor?: Prisma.StateWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` States from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` States.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of States.
	 */
	distinct?: Prisma.StateScalarFieldEnum | Prisma.StateScalarFieldEnum[];
};

/**
 * State findFirstOrThrow
 */
export type StateFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * Filter, which State to fetch.
	 */
	where?: Prisma.StateWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of States to fetch.
	 */
	orderBy?:
		| Prisma.StateOrderByWithRelationInput
		| Prisma.StateOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for States.
	 */
	cursor?: Prisma.StateWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` States from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` States.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of States.
	 */
	distinct?: Prisma.StateScalarFieldEnum | Prisma.StateScalarFieldEnum[];
};

/**
 * State findMany
 */
export type StateFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * Filter, which States to fetch.
	 */
	where?: Prisma.StateWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of States to fetch.
	 */
	orderBy?:
		| Prisma.StateOrderByWithRelationInput
		| Prisma.StateOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing States.
	 */
	cursor?: Prisma.StateWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` States from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` States.
	 */
	skip?: number;
	distinct?: Prisma.StateScalarFieldEnum | Prisma.StateScalarFieldEnum[];
};

/**
 * State create
 */
export type StateCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * The data needed to create a State.
	 */
	data: Prisma.XOR<Prisma.StateCreateInput, Prisma.StateUncheckedCreateInput>;
};

/**
 * State createMany
 */
export type StateCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many States.
	 */
	data: Prisma.StateCreateManyInput | Prisma.StateCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * State createManyAndReturn
 */
export type StateCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * The data used to create many States.
	 */
	data: Prisma.StateCreateManyInput | Prisma.StateCreateManyInput[];
	skipDuplicates?: boolean;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * State update
 */
export type StateUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * The data needed to update a State.
	 */
	data: Prisma.XOR<Prisma.StateUpdateInput, Prisma.StateUncheckedUpdateInput>;
	/**
	 * Choose, which State to update.
	 */
	where: Prisma.StateWhereUniqueInput;
};

/**
 * State updateMany
 */
export type StateUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update States.
	 */
	data: Prisma.XOR<
		Prisma.StateUpdateManyMutationInput,
		Prisma.StateUncheckedUpdateManyInput
	>;
	/**
	 * Filter which States to update
	 */
	where?: Prisma.StateWhereInput;
	/**
	 * Limit how many States to update.
	 */
	limit?: number;
};

/**
 * State updateManyAndReturn
 */
export type StateUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * The data used to update States.
	 */
	data: Prisma.XOR<
		Prisma.StateUpdateManyMutationInput,
		Prisma.StateUncheckedUpdateManyInput
	>;
	/**
	 * Filter which States to update
	 */
	where?: Prisma.StateWhereInput;
	/**
	 * Limit how many States to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * State upsert
 */
export type StateUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * The filter to search for the State to update in case it exists.
	 */
	where: Prisma.StateWhereUniqueInput;
	/**
	 * In case the State found by the `where` argument doesn't exist, create a new State with this data.
	 */
	create: Prisma.XOR<Prisma.StateCreateInput, Prisma.StateUncheckedCreateInput>;
	/**
	 * In case the State was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<Prisma.StateUpdateInput, Prisma.StateUncheckedUpdateInput>;
};

/**
 * State delete
 */
export type StateDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
	/**
	 * Filter which State to delete.
	 */
	where: Prisma.StateWhereUniqueInput;
};

/**
 * State deleteMany
 */
export type StateDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which States to delete
	 */
	where?: Prisma.StateWhereInput;
	/**
	 * Limit how many States to delete.
	 */
	limit?: number;
};

/**
 * State.addresses
 */
export type State$addressesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Address
	 */
	select?: Prisma.AddressSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Address
	 */
	omit?: Prisma.AddressOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AddressInclude<ExtArgs> | null;
	where?: Prisma.AddressWhereInput;
	orderBy?:
		| Prisma.AddressOrderByWithRelationInput
		| Prisma.AddressOrderByWithRelationInput[];
	cursor?: Prisma.AddressWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.AddressScalarFieldEnum | Prisma.AddressScalarFieldEnum[];
};

/**
 * State.customerAddresses
 */
export type State$customerAddressesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CustomerAddress
	 */
	select?: Prisma.CustomerAddressSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the CustomerAddress
	 */
	omit?: Prisma.CustomerAddressOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CustomerAddressInclude<ExtArgs> | null;
	where?: Prisma.CustomerAddressWhereInput;
	orderBy?:
		| Prisma.CustomerAddressOrderByWithRelationInput
		| Prisma.CustomerAddressOrderByWithRelationInput[];
	cursor?: Prisma.CustomerAddressWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.CustomerAddressScalarFieldEnum
		| Prisma.CustomerAddressScalarFieldEnum[];
};

/**
 * State.presetLocations
 */
export type State$presetLocationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the PresetLocation
	 */
	select?: Prisma.PresetLocationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the PresetLocation
	 */
	omit?: Prisma.PresetLocationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PresetLocationInclude<ExtArgs> | null;
	where?: Prisma.PresetLocationWhereInput;
	orderBy?:
		| Prisma.PresetLocationOrderByWithRelationInput
		| Prisma.PresetLocationOrderByWithRelationInput[];
	cursor?: Prisma.PresetLocationWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.PresetLocationScalarFieldEnum
		| Prisma.PresetLocationScalarFieldEnum[];
};

/**
 * State.storefrontUser
 */
export type State$storefrontUserArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the StorefrontUser
	 */
	select?: Prisma.StorefrontUserSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the StorefrontUser
	 */
	omit?: Prisma.StorefrontUserOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StorefrontUserInclude<ExtArgs> | null;
	where?: Prisma.StorefrontUserWhereInput;
	orderBy?:
		| Prisma.StorefrontUserOrderByWithRelationInput
		| Prisma.StorefrontUserOrderByWithRelationInput[];
	cursor?: Prisma.StorefrontUserWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.StorefrontUserScalarFieldEnum
		| Prisma.StorefrontUserScalarFieldEnum[];
};

/**
 * State.villages
 */
export type State$villagesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Village
	 */
	select?: Prisma.VillageSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Village
	 */
	omit?: Prisma.VillageOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.VillageInclude<ExtArgs> | null;
	where?: Prisma.VillageWhereInput;
	orderBy?:
		| Prisma.VillageOrderByWithRelationInput
		| Prisma.VillageOrderByWithRelationInput[];
	cursor?: Prisma.VillageWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.VillageScalarFieldEnum | Prisma.VillageScalarFieldEnum[];
};

/**
 * State without action
 */
export type StateDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the State
	 */
	select?: Prisma.StateSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the State
	 */
	omit?: Prisma.StateOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.StateInclude<ExtArgs> | null;
};
