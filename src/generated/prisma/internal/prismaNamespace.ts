
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 6.19.0
 * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
 */
export const prismaVersion: PrismaVersion = {
  client: "6.19.0",
  engine: "2ba551f319ab1df4bc874a89965d8b3641056773"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Service: 'Service',
  ChargeType: 'ChargeType',
  VehicleBrand: 'VehicleBrand',
  VehicleModel: 'VehicleModel',
  VehicleBodyType: 'VehicleBodyType',
  VehicleStatus: 'VehicleStatus',
  FuelType: 'FuelType',
  Transmission: 'Transmission',
  VehicleFeature: 'VehicleFeature',
  WheelDrive: 'WheelDrive',
  InvoiceSequence: 'InvoiceSequence',
  Country: 'Country',
  State: 'State',
  Village: 'Village',
  MaintenanceService: 'MaintenanceService',
  DocumentType: 'DocumentType',
  PresetLocation: 'PresetLocation',
  LicenseClass: 'LicenseClass',
  MessengerApp: 'MessengerApp',
  Equipment: 'Equipment',
  ContactType: 'ContactType',
  PaymentType: 'PaymentType',
  VendorType: 'VendorType',
  Port: 'Port',
  Customer: 'Customer',
  CustomerMessengerApp: 'CustomerMessengerApp',
  CustomerAddress: 'CustomerAddress',
  CustomerDocument: 'CustomerDocument',
  DriverLicense: 'DriverLicense',
  CustomerViolation: 'CustomerViolation',
  RentalAgreement: 'RentalAgreement',
  Invoice: 'Invoice',
  PaymentReceipt: 'PaymentReceipt',
  CaribbeanCountry: 'CaribbeanCountry',
  ShopDMMerchant: 'ShopDMMerchant',
  Currency: 'Currency',
  TenantCurrencyRate: 'TenantCurrencyRate',
  ExchangeRate: 'ExchangeRate',
  Form: 'Form',
  FormResponse: 'FormResponse',
  RentalActivity: 'RentalActivity',
  TenantNotification: 'TenantNotification',
  NotificationReadStatus: 'NotificationReadStatus',
  AppPermission: 'AppPermission',
  PermissionCategory: 'PermissionCategory',
  Rental: 'Rental',
  StorefrontBooking: 'StorefrontBooking',
  RentalDriver: 'RentalDriver',
  Values: 'Values',
  RentalExtra: 'RentalExtra',
  RentalCharge: 'RentalCharge',
  VesselInfo: 'VesselInfo',
  TenantWeeklyStats: 'TenantWeeklyStats',
  TenantYearlyStats: 'TenantYearlyStats',
  TenantMonthlyStats: 'TenantMonthlyStats',
  TenantMonthlyRentalStats: 'TenantMonthlyRentalStats',
  TenantRatings: 'TenantRatings',
  SiteRatings: 'SiteRatings',
  SubscriptionPlan: 'SubscriptionPlan',
  PlanFeatures: 'PlanFeatures',
  PlanDetails: 'PlanDetails',
  Tenant: 'Tenant',
  EmailVerification: 'EmailVerification',
  PaymentMethod: 'PaymentMethod',
  Address: 'Address',
  TenantLocation: 'TenantLocation',
  TenantInsurance: 'TenantInsurance',
  TenantEquipment: 'TenantEquipment',
  TenantService: 'TenantService',
  TenantSubscription: 'TenantSubscription',
  TenantContact: 'TenantContact',
  TenantReminders: 'TenantReminders',
  CancellationPolicy: 'CancellationPolicy',
  LatePolicy: 'LatePolicy',
  TenantViolation: 'TenantViolation',
  TenantVendor: 'TenantVendor',
  VerificationRequest: 'VerificationRequest',
  Transactions: 'Transactions',
  Payment: 'Payment',
  Refund: 'Refund',
  Expense: 'Expense',
  User: 'User',
  StorefrontUser: 'StorefrontUser',
  AdminUser: 'AdminUser',
  UserRole: 'UserRole',
  UserRolePermission: 'UserRolePermission',
  EmailTokens: 'EmailTokens',
  Vehicle: 'Vehicle',
  VehicleDiscount: 'VehicleDiscount',
  VehicleDamage: 'VehicleDamage',
  VehiclePart: 'VehiclePart',
  FuelPolicy: 'FuelPolicy',
  VehicleServiceLog: 'VehicleServiceLog',
  VehicleMaintenance: 'VehicleMaintenance',
  VehicleServiceSchedule: 'VehicleServiceSchedule',
  BookingVehicleHistory: 'BookingVehicleHistory',
  VehicleEvent: 'VehicleEvent'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "service" | "chargeType" | "vehicleBrand" | "vehicleModel" | "vehicleBodyType" | "vehicleStatus" | "fuelType" | "transmission" | "vehicleFeature" | "wheelDrive" | "invoiceSequence" | "country" | "state" | "village" | "maintenanceService" | "documentType" | "presetLocation" | "licenseClass" | "messengerApp" | "equipment" | "contactType" | "paymentType" | "vendorType" | "port" | "customer" | "customerMessengerApp" | "customerAddress" | "customerDocument" | "driverLicense" | "customerViolation" | "rentalAgreement" | "invoice" | "paymentReceipt" | "caribbeanCountry" | "shopDMMerchant" | "currency" | "tenantCurrencyRate" | "exchangeRate" | "form" | "formResponse" | "rentalActivity" | "tenantNotification" | "notificationReadStatus" | "appPermission" | "permissionCategory" | "rental" | "storefrontBooking" | "rentalDriver" | "values" | "rentalExtra" | "rentalCharge" | "vesselInfo" | "tenantWeeklyStats" | "tenantYearlyStats" | "tenantMonthlyStats" | "tenantMonthlyRentalStats" | "tenantRatings" | "siteRatings" | "subscriptionPlan" | "planFeatures" | "planDetails" | "tenant" | "emailVerification" | "paymentMethod" | "address" | "tenantLocation" | "tenantInsurance" | "tenantEquipment" | "tenantService" | "tenantSubscription" | "tenantContact" | "tenantReminders" | "cancellationPolicy" | "latePolicy" | "tenantViolation" | "tenantVendor" | "verificationRequest" | "transactions" | "payment" | "refund" | "expense" | "user" | "storefrontUser" | "adminUser" | "userRole" | "userRolePermission" | "emailTokens" | "vehicle" | "vehicleDiscount" | "vehicleDamage" | "vehiclePart" | "fuelPolicy" | "vehicleServiceLog" | "vehicleMaintenance" | "vehicleServiceSchedule" | "bookingVehicleHistory" | "vehicleEvent"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Service: {
      payload: Prisma.$ServicePayload<ExtArgs>
      fields: Prisma.ServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findFirst: {
          args: Prisma.ServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findMany: {
          args: Prisma.ServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        create: {
          args: Prisma.ServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        createMany: {
          args: Prisma.ServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        delete: {
          args: Prisma.ServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        update: {
          args: Prisma.ServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        deleteMany: {
          args: Prisma.ServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        upsert: {
          args: Prisma.ServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        aggregate: {
          args: Prisma.ServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateService>
        }
        groupBy: {
          args: Prisma.ServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceCountAggregateOutputType> | number
        }
      }
    }
    ChargeType: {
      payload: Prisma.$ChargeTypePayload<ExtArgs>
      fields: Prisma.ChargeTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChargeTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChargeTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>
        }
        findFirst: {
          args: Prisma.ChargeTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChargeTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>
        }
        findMany: {
          args: Prisma.ChargeTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>[]
        }
        create: {
          args: Prisma.ChargeTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>
        }
        createMany: {
          args: Prisma.ChargeTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChargeTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>[]
        }
        delete: {
          args: Prisma.ChargeTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>
        }
        update: {
          args: Prisma.ChargeTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>
        }
        deleteMany: {
          args: Prisma.ChargeTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChargeTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChargeTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>[]
        }
        upsert: {
          args: Prisma.ChargeTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChargeTypePayload>
        }
        aggregate: {
          args: Prisma.ChargeTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChargeType>
        }
        groupBy: {
          args: Prisma.ChargeTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChargeTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChargeTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChargeTypeCountAggregateOutputType> | number
        }
      }
    }
    VehicleBrand: {
      payload: Prisma.$VehicleBrandPayload<ExtArgs>
      fields: Prisma.VehicleBrandFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleBrandFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleBrandFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>
        }
        findFirst: {
          args: Prisma.VehicleBrandFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleBrandFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>
        }
        findMany: {
          args: Prisma.VehicleBrandFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>[]
        }
        create: {
          args: Prisma.VehicleBrandCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>
        }
        createMany: {
          args: Prisma.VehicleBrandCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleBrandCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>[]
        }
        delete: {
          args: Prisma.VehicleBrandDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>
        }
        update: {
          args: Prisma.VehicleBrandUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>
        }
        deleteMany: {
          args: Prisma.VehicleBrandDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleBrandUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleBrandUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>[]
        }
        upsert: {
          args: Prisma.VehicleBrandUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBrandPayload>
        }
        aggregate: {
          args: Prisma.VehicleBrandAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleBrand>
        }
        groupBy: {
          args: Prisma.VehicleBrandGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleBrandGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleBrandCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleBrandCountAggregateOutputType> | number
        }
      }
    }
    VehicleModel: {
      payload: Prisma.$VehicleModelPayload<ExtArgs>
      fields: Prisma.VehicleModelFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleModelFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleModelFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>
        }
        findFirst: {
          args: Prisma.VehicleModelFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleModelFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>
        }
        findMany: {
          args: Prisma.VehicleModelFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>[]
        }
        create: {
          args: Prisma.VehicleModelCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>
        }
        createMany: {
          args: Prisma.VehicleModelCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleModelCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>[]
        }
        delete: {
          args: Prisma.VehicleModelDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>
        }
        update: {
          args: Prisma.VehicleModelUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>
        }
        deleteMany: {
          args: Prisma.VehicleModelDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleModelUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleModelUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>[]
        }
        upsert: {
          args: Prisma.VehicleModelUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleModelPayload>
        }
        aggregate: {
          args: Prisma.VehicleModelAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleModel>
        }
        groupBy: {
          args: Prisma.VehicleModelGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleModelGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleModelCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleModelCountAggregateOutputType> | number
        }
      }
    }
    VehicleBodyType: {
      payload: Prisma.$VehicleBodyTypePayload<ExtArgs>
      fields: Prisma.VehicleBodyTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleBodyTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleBodyTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>
        }
        findFirst: {
          args: Prisma.VehicleBodyTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleBodyTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>
        }
        findMany: {
          args: Prisma.VehicleBodyTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>[]
        }
        create: {
          args: Prisma.VehicleBodyTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>
        }
        createMany: {
          args: Prisma.VehicleBodyTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleBodyTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>[]
        }
        delete: {
          args: Prisma.VehicleBodyTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>
        }
        update: {
          args: Prisma.VehicleBodyTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>
        }
        deleteMany: {
          args: Prisma.VehicleBodyTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleBodyTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleBodyTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>[]
        }
        upsert: {
          args: Prisma.VehicleBodyTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleBodyTypePayload>
        }
        aggregate: {
          args: Prisma.VehicleBodyTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleBodyType>
        }
        groupBy: {
          args: Prisma.VehicleBodyTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleBodyTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleBodyTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleBodyTypeCountAggregateOutputType> | number
        }
      }
    }
    VehicleStatus: {
      payload: Prisma.$VehicleStatusPayload<ExtArgs>
      fields: Prisma.VehicleStatusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleStatusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleStatusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>
        }
        findFirst: {
          args: Prisma.VehicleStatusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleStatusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>
        }
        findMany: {
          args: Prisma.VehicleStatusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>[]
        }
        create: {
          args: Prisma.VehicleStatusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>
        }
        createMany: {
          args: Prisma.VehicleStatusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleStatusCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>[]
        }
        delete: {
          args: Prisma.VehicleStatusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>
        }
        update: {
          args: Prisma.VehicleStatusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>
        }
        deleteMany: {
          args: Prisma.VehicleStatusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleStatusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleStatusUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>[]
        }
        upsert: {
          args: Prisma.VehicleStatusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleStatusPayload>
        }
        aggregate: {
          args: Prisma.VehicleStatusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleStatus>
        }
        groupBy: {
          args: Prisma.VehicleStatusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleStatusGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleStatusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleStatusCountAggregateOutputType> | number
        }
      }
    }
    FuelType: {
      payload: Prisma.$FuelTypePayload<ExtArgs>
      fields: Prisma.FuelTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FuelTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FuelTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>
        }
        findFirst: {
          args: Prisma.FuelTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FuelTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>
        }
        findMany: {
          args: Prisma.FuelTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>[]
        }
        create: {
          args: Prisma.FuelTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>
        }
        createMany: {
          args: Prisma.FuelTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FuelTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>[]
        }
        delete: {
          args: Prisma.FuelTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>
        }
        update: {
          args: Prisma.FuelTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>
        }
        deleteMany: {
          args: Prisma.FuelTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FuelTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FuelTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>[]
        }
        upsert: {
          args: Prisma.FuelTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelTypePayload>
        }
        aggregate: {
          args: Prisma.FuelTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFuelType>
        }
        groupBy: {
          args: Prisma.FuelTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FuelTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.FuelTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FuelTypeCountAggregateOutputType> | number
        }
      }
    }
    Transmission: {
      payload: Prisma.$TransmissionPayload<ExtArgs>
      fields: Prisma.TransmissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransmissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransmissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>
        }
        findFirst: {
          args: Prisma.TransmissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransmissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>
        }
        findMany: {
          args: Prisma.TransmissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>[]
        }
        create: {
          args: Prisma.TransmissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>
        }
        createMany: {
          args: Prisma.TransmissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransmissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>[]
        }
        delete: {
          args: Prisma.TransmissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>
        }
        update: {
          args: Prisma.TransmissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>
        }
        deleteMany: {
          args: Prisma.TransmissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransmissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransmissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>[]
        }
        upsert: {
          args: Prisma.TransmissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransmissionPayload>
        }
        aggregate: {
          args: Prisma.TransmissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransmission>
        }
        groupBy: {
          args: Prisma.TransmissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransmissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransmissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransmissionCountAggregateOutputType> | number
        }
      }
    }
    VehicleFeature: {
      payload: Prisma.$VehicleFeaturePayload<ExtArgs>
      fields: Prisma.VehicleFeatureFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleFeatureFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleFeatureFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>
        }
        findFirst: {
          args: Prisma.VehicleFeatureFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleFeatureFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>
        }
        findMany: {
          args: Prisma.VehicleFeatureFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>[]
        }
        create: {
          args: Prisma.VehicleFeatureCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>
        }
        createMany: {
          args: Prisma.VehicleFeatureCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleFeatureCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>[]
        }
        delete: {
          args: Prisma.VehicleFeatureDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>
        }
        update: {
          args: Prisma.VehicleFeatureUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>
        }
        deleteMany: {
          args: Prisma.VehicleFeatureDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleFeatureUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleFeatureUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>[]
        }
        upsert: {
          args: Prisma.VehicleFeatureUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleFeaturePayload>
        }
        aggregate: {
          args: Prisma.VehicleFeatureAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleFeature>
        }
        groupBy: {
          args: Prisma.VehicleFeatureGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleFeatureGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleFeatureCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleFeatureCountAggregateOutputType> | number
        }
      }
    }
    WheelDrive: {
      payload: Prisma.$WheelDrivePayload<ExtArgs>
      fields: Prisma.WheelDriveFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WheelDriveFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WheelDriveFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>
        }
        findFirst: {
          args: Prisma.WheelDriveFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WheelDriveFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>
        }
        findMany: {
          args: Prisma.WheelDriveFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>[]
        }
        create: {
          args: Prisma.WheelDriveCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>
        }
        createMany: {
          args: Prisma.WheelDriveCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WheelDriveCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>[]
        }
        delete: {
          args: Prisma.WheelDriveDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>
        }
        update: {
          args: Prisma.WheelDriveUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>
        }
        deleteMany: {
          args: Prisma.WheelDriveDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WheelDriveUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WheelDriveUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>[]
        }
        upsert: {
          args: Prisma.WheelDriveUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WheelDrivePayload>
        }
        aggregate: {
          args: Prisma.WheelDriveAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWheelDrive>
        }
        groupBy: {
          args: Prisma.WheelDriveGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WheelDriveGroupByOutputType>[]
        }
        count: {
          args: Prisma.WheelDriveCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WheelDriveCountAggregateOutputType> | number
        }
      }
    }
    InvoiceSequence: {
      payload: Prisma.$InvoiceSequencePayload<ExtArgs>
      fields: Prisma.InvoiceSequenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceSequenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceSequenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>
        }
        findFirst: {
          args: Prisma.InvoiceSequenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceSequenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>
        }
        findMany: {
          args: Prisma.InvoiceSequenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>[]
        }
        create: {
          args: Prisma.InvoiceSequenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>
        }
        createMany: {
          args: Prisma.InvoiceSequenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceSequenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>[]
        }
        delete: {
          args: Prisma.InvoiceSequenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>
        }
        update: {
          args: Prisma.InvoiceSequenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceSequenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceSequenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceSequenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceSequenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceSequencePayload>
        }
        aggregate: {
          args: Prisma.InvoiceSequenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoiceSequence>
        }
        groupBy: {
          args: Prisma.InvoiceSequenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceSequenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceSequenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceSequenceCountAggregateOutputType> | number
        }
      }
    }
    Country: {
      payload: Prisma.$CountryPayload<ExtArgs>
      fields: Prisma.CountryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CountryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>
        }
        findFirst: {
          args: Prisma.CountryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>
        }
        findMany: {
          args: Prisma.CountryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>[]
        }
        create: {
          args: Prisma.CountryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>
        }
        createMany: {
          args: Prisma.CountryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CountryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>[]
        }
        delete: {
          args: Prisma.CountryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>
        }
        update: {
          args: Prisma.CountryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>
        }
        deleteMany: {
          args: Prisma.CountryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CountryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CountryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>[]
        }
        upsert: {
          args: Prisma.CountryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CountryPayload>
        }
        aggregate: {
          args: Prisma.CountryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCountry>
        }
        groupBy: {
          args: Prisma.CountryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CountryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CountryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CountryCountAggregateOutputType> | number
        }
      }
    }
    State: {
      payload: Prisma.$StatePayload<ExtArgs>
      fields: Prisma.StateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>
        }
        findFirst: {
          args: Prisma.StateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>
        }
        findMany: {
          args: Prisma.StateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>[]
        }
        create: {
          args: Prisma.StateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>
        }
        createMany: {
          args: Prisma.StateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>[]
        }
        delete: {
          args: Prisma.StateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>
        }
        update: {
          args: Prisma.StateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>
        }
        deleteMany: {
          args: Prisma.StateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>[]
        }
        upsert: {
          args: Prisma.StateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatePayload>
        }
        aggregate: {
          args: Prisma.StateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateState>
        }
        groupBy: {
          args: Prisma.StateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StateGroupByOutputType>[]
        }
        count: {
          args: Prisma.StateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StateCountAggregateOutputType> | number
        }
      }
    }
    Village: {
      payload: Prisma.$VillagePayload<ExtArgs>
      fields: Prisma.VillageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VillageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VillageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>
        }
        findFirst: {
          args: Prisma.VillageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VillageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>
        }
        findMany: {
          args: Prisma.VillageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>[]
        }
        create: {
          args: Prisma.VillageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>
        }
        createMany: {
          args: Prisma.VillageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VillageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>[]
        }
        delete: {
          args: Prisma.VillageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>
        }
        update: {
          args: Prisma.VillageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>
        }
        deleteMany: {
          args: Prisma.VillageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VillageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VillageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>[]
        }
        upsert: {
          args: Prisma.VillageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VillagePayload>
        }
        aggregate: {
          args: Prisma.VillageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVillage>
        }
        groupBy: {
          args: Prisma.VillageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VillageGroupByOutputType>[]
        }
        count: {
          args: Prisma.VillageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VillageCountAggregateOutputType> | number
        }
      }
    }
    MaintenanceService: {
      payload: Prisma.$MaintenanceServicePayload<ExtArgs>
      fields: Prisma.MaintenanceServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MaintenanceServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MaintenanceServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>
        }
        findFirst: {
          args: Prisma.MaintenanceServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MaintenanceServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>
        }
        findMany: {
          args: Prisma.MaintenanceServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>[]
        }
        create: {
          args: Prisma.MaintenanceServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>
        }
        createMany: {
          args: Prisma.MaintenanceServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MaintenanceServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>[]
        }
        delete: {
          args: Prisma.MaintenanceServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>
        }
        update: {
          args: Prisma.MaintenanceServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>
        }
        deleteMany: {
          args: Prisma.MaintenanceServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MaintenanceServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MaintenanceServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>[]
        }
        upsert: {
          args: Prisma.MaintenanceServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MaintenanceServicePayload>
        }
        aggregate: {
          args: Prisma.MaintenanceServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMaintenanceService>
        }
        groupBy: {
          args: Prisma.MaintenanceServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.MaintenanceServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MaintenanceServiceCountAggregateOutputType> | number
        }
      }
    }
    DocumentType: {
      payload: Prisma.$DocumentTypePayload<ExtArgs>
      fields: Prisma.DocumentTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>
        }
        findFirst: {
          args: Prisma.DocumentTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>
        }
        findMany: {
          args: Prisma.DocumentTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>[]
        }
        create: {
          args: Prisma.DocumentTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>
        }
        createMany: {
          args: Prisma.DocumentTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>[]
        }
        delete: {
          args: Prisma.DocumentTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>
        }
        update: {
          args: Prisma.DocumentTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>
        }
        deleteMany: {
          args: Prisma.DocumentTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>[]
        }
        upsert: {
          args: Prisma.DocumentTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentTypePayload>
        }
        aggregate: {
          args: Prisma.DocumentTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocumentType>
        }
        groupBy: {
          args: Prisma.DocumentTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentTypeCountAggregateOutputType> | number
        }
      }
    }
    PresetLocation: {
      payload: Prisma.$PresetLocationPayload<ExtArgs>
      fields: Prisma.PresetLocationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PresetLocationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PresetLocationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>
        }
        findFirst: {
          args: Prisma.PresetLocationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PresetLocationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>
        }
        findMany: {
          args: Prisma.PresetLocationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>[]
        }
        create: {
          args: Prisma.PresetLocationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>
        }
        createMany: {
          args: Prisma.PresetLocationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PresetLocationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>[]
        }
        delete: {
          args: Prisma.PresetLocationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>
        }
        update: {
          args: Prisma.PresetLocationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>
        }
        deleteMany: {
          args: Prisma.PresetLocationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PresetLocationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PresetLocationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>[]
        }
        upsert: {
          args: Prisma.PresetLocationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PresetLocationPayload>
        }
        aggregate: {
          args: Prisma.PresetLocationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePresetLocation>
        }
        groupBy: {
          args: Prisma.PresetLocationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PresetLocationGroupByOutputType>[]
        }
        count: {
          args: Prisma.PresetLocationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PresetLocationCountAggregateOutputType> | number
        }
      }
    }
    LicenseClass: {
      payload: Prisma.$LicenseClassPayload<ExtArgs>
      fields: Prisma.LicenseClassFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LicenseClassFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LicenseClassFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>
        }
        findFirst: {
          args: Prisma.LicenseClassFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LicenseClassFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>
        }
        findMany: {
          args: Prisma.LicenseClassFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>[]
        }
        create: {
          args: Prisma.LicenseClassCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>
        }
        createMany: {
          args: Prisma.LicenseClassCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LicenseClassCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>[]
        }
        delete: {
          args: Prisma.LicenseClassDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>
        }
        update: {
          args: Prisma.LicenseClassUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>
        }
        deleteMany: {
          args: Prisma.LicenseClassDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LicenseClassUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LicenseClassUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>[]
        }
        upsert: {
          args: Prisma.LicenseClassUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LicenseClassPayload>
        }
        aggregate: {
          args: Prisma.LicenseClassAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLicenseClass>
        }
        groupBy: {
          args: Prisma.LicenseClassGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LicenseClassGroupByOutputType>[]
        }
        count: {
          args: Prisma.LicenseClassCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LicenseClassCountAggregateOutputType> | number
        }
      }
    }
    MessengerApp: {
      payload: Prisma.$MessengerAppPayload<ExtArgs>
      fields: Prisma.MessengerAppFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessengerAppFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessengerAppFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>
        }
        findFirst: {
          args: Prisma.MessengerAppFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessengerAppFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>
        }
        findMany: {
          args: Prisma.MessengerAppFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>[]
        }
        create: {
          args: Prisma.MessengerAppCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>
        }
        createMany: {
          args: Prisma.MessengerAppCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessengerAppCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>[]
        }
        delete: {
          args: Prisma.MessengerAppDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>
        }
        update: {
          args: Prisma.MessengerAppUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>
        }
        deleteMany: {
          args: Prisma.MessengerAppDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessengerAppUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessengerAppUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>[]
        }
        upsert: {
          args: Prisma.MessengerAppUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessengerAppPayload>
        }
        aggregate: {
          args: Prisma.MessengerAppAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessengerApp>
        }
        groupBy: {
          args: Prisma.MessengerAppGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessengerAppGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessengerAppCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessengerAppCountAggregateOutputType> | number
        }
      }
    }
    Equipment: {
      payload: Prisma.$EquipmentPayload<ExtArgs>
      fields: Prisma.EquipmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>
        }
        findFirst: {
          args: Prisma.EquipmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>
        }
        findMany: {
          args: Prisma.EquipmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
        }
        create: {
          args: Prisma.EquipmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>
        }
        createMany: {
          args: Prisma.EquipmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
        }
        delete: {
          args: Prisma.EquipmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>
        }
        update: {
          args: Prisma.EquipmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>
        }
        deleteMany: {
          args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
        }
        upsert: {
          args: Prisma.EquipmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EquipmentPayload>
        }
        aggregate: {
          args: Prisma.EquipmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEquipment>
        }
        groupBy: {
          args: Prisma.EquipmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EquipmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.EquipmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EquipmentCountAggregateOutputType> | number
        }
      }
    }
    ContactType: {
      payload: Prisma.$ContactTypePayload<ExtArgs>
      fields: Prisma.ContactTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ContactTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ContactTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>
        }
        findFirst: {
          args: Prisma.ContactTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ContactTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>
        }
        findMany: {
          args: Prisma.ContactTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>[]
        }
        create: {
          args: Prisma.ContactTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>
        }
        createMany: {
          args: Prisma.ContactTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ContactTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>[]
        }
        delete: {
          args: Prisma.ContactTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>
        }
        update: {
          args: Prisma.ContactTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>
        }
        deleteMany: {
          args: Prisma.ContactTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ContactTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ContactTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>[]
        }
        upsert: {
          args: Prisma.ContactTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactTypePayload>
        }
        aggregate: {
          args: Prisma.ContactTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContactType>
        }
        groupBy: {
          args: Prisma.ContactTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.ContactTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactTypeCountAggregateOutputType> | number
        }
      }
    }
    PaymentType: {
      payload: Prisma.$PaymentTypePayload<ExtArgs>
      fields: Prisma.PaymentTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>
        }
        findFirst: {
          args: Prisma.PaymentTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>
        }
        findMany: {
          args: Prisma.PaymentTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>[]
        }
        create: {
          args: Prisma.PaymentTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>
        }
        createMany: {
          args: Prisma.PaymentTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>[]
        }
        delete: {
          args: Prisma.PaymentTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>
        }
        update: {
          args: Prisma.PaymentTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>
        }
        deleteMany: {
          args: Prisma.PaymentTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>[]
        }
        upsert: {
          args: Prisma.PaymentTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentTypePayload>
        }
        aggregate: {
          args: Prisma.PaymentTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentType>
        }
        groupBy: {
          args: Prisma.PaymentTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentTypeCountAggregateOutputType> | number
        }
      }
    }
    VendorType: {
      payload: Prisma.$VendorTypePayload<ExtArgs>
      fields: Prisma.VendorTypeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VendorTypeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VendorTypeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>
        }
        findFirst: {
          args: Prisma.VendorTypeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VendorTypeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>
        }
        findMany: {
          args: Prisma.VendorTypeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>[]
        }
        create: {
          args: Prisma.VendorTypeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>
        }
        createMany: {
          args: Prisma.VendorTypeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VendorTypeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>[]
        }
        delete: {
          args: Prisma.VendorTypeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>
        }
        update: {
          args: Prisma.VendorTypeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>
        }
        deleteMany: {
          args: Prisma.VendorTypeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VendorTypeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VendorTypeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>[]
        }
        upsert: {
          args: Prisma.VendorTypeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VendorTypePayload>
        }
        aggregate: {
          args: Prisma.VendorTypeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVendorType>
        }
        groupBy: {
          args: Prisma.VendorTypeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VendorTypeGroupByOutputType>[]
        }
        count: {
          args: Prisma.VendorTypeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VendorTypeCountAggregateOutputType> | number
        }
      }
    }
    Port: {
      payload: Prisma.$PortPayload<ExtArgs>
      fields: Prisma.PortFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PortFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PortFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>
        }
        findFirst: {
          args: Prisma.PortFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PortFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>
        }
        findMany: {
          args: Prisma.PortFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>[]
        }
        create: {
          args: Prisma.PortCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>
        }
        createMany: {
          args: Prisma.PortCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PortCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>[]
        }
        delete: {
          args: Prisma.PortDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>
        }
        update: {
          args: Prisma.PortUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>
        }
        deleteMany: {
          args: Prisma.PortDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PortUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PortUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>[]
        }
        upsert: {
          args: Prisma.PortUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PortPayload>
        }
        aggregate: {
          args: Prisma.PortAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePort>
        }
        groupBy: {
          args: Prisma.PortGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PortGroupByOutputType>[]
        }
        count: {
          args: Prisma.PortCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PortCountAggregateOutputType> | number
        }
      }
    }
    Customer: {
      payload: Prisma.$CustomerPayload<ExtArgs>
      fields: Prisma.CustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findFirst: {
          args: Prisma.CustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        findMany: {
          args: Prisma.CustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        create: {
          args: Prisma.CustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        createMany: {
          args: Prisma.CustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        delete: {
          args: Prisma.CustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        update: {
          args: Prisma.CustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        deleteMany: {
          args: Prisma.CustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>[]
        }
        upsert: {
          args: Prisma.CustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerPayload>
        }
        aggregate: {
          args: Prisma.CustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomer>
        }
        groupBy: {
          args: Prisma.CustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerCountAggregateOutputType> | number
        }
      }
    }
    CustomerMessengerApp: {
      payload: Prisma.$CustomerMessengerAppPayload<ExtArgs>
      fields: Prisma.CustomerMessengerAppFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerMessengerAppFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerMessengerAppFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>
        }
        findFirst: {
          args: Prisma.CustomerMessengerAppFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerMessengerAppFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>
        }
        findMany: {
          args: Prisma.CustomerMessengerAppFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>[]
        }
        create: {
          args: Prisma.CustomerMessengerAppCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>
        }
        createMany: {
          args: Prisma.CustomerMessengerAppCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerMessengerAppCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>[]
        }
        delete: {
          args: Prisma.CustomerMessengerAppDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>
        }
        update: {
          args: Prisma.CustomerMessengerAppUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>
        }
        deleteMany: {
          args: Prisma.CustomerMessengerAppDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerMessengerAppUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerMessengerAppUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>[]
        }
        upsert: {
          args: Prisma.CustomerMessengerAppUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerMessengerAppPayload>
        }
        aggregate: {
          args: Prisma.CustomerMessengerAppAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerMessengerApp>
        }
        groupBy: {
          args: Prisma.CustomerMessengerAppGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerMessengerAppGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerMessengerAppCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerMessengerAppCountAggregateOutputType> | number
        }
      }
    }
    CustomerAddress: {
      payload: Prisma.$CustomerAddressPayload<ExtArgs>
      fields: Prisma.CustomerAddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        findFirst: {
          args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        findMany: {
          args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
        }
        create: {
          args: Prisma.CustomerAddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        createMany: {
          args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
        }
        delete: {
          args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        update: {
          args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        deleteMany: {
          args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerAddressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
        }
        upsert: {
          args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
        }
        aggregate: {
          args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerAddress>
        }
        groupBy: {
          args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerAddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerAddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerAddressCountAggregateOutputType> | number
        }
      }
    }
    CustomerDocument: {
      payload: Prisma.$CustomerDocumentPayload<ExtArgs>
      fields: Prisma.CustomerDocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerDocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerDocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>
        }
        findFirst: {
          args: Prisma.CustomerDocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerDocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>
        }
        findMany: {
          args: Prisma.CustomerDocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>[]
        }
        create: {
          args: Prisma.CustomerDocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>
        }
        createMany: {
          args: Prisma.CustomerDocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerDocumentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>[]
        }
        delete: {
          args: Prisma.CustomerDocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>
        }
        update: {
          args: Prisma.CustomerDocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>
        }
        deleteMany: {
          args: Prisma.CustomerDocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerDocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerDocumentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>[]
        }
        upsert: {
          args: Prisma.CustomerDocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerDocumentPayload>
        }
        aggregate: {
          args: Prisma.CustomerDocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerDocument>
        }
        groupBy: {
          args: Prisma.CustomerDocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerDocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerDocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerDocumentCountAggregateOutputType> | number
        }
      }
    }
    DriverLicense: {
      payload: Prisma.$DriverLicensePayload<ExtArgs>
      fields: Prisma.DriverLicenseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DriverLicenseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DriverLicenseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>
        }
        findFirst: {
          args: Prisma.DriverLicenseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DriverLicenseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>
        }
        findMany: {
          args: Prisma.DriverLicenseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>[]
        }
        create: {
          args: Prisma.DriverLicenseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>
        }
        createMany: {
          args: Prisma.DriverLicenseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DriverLicenseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>[]
        }
        delete: {
          args: Prisma.DriverLicenseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>
        }
        update: {
          args: Prisma.DriverLicenseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>
        }
        deleteMany: {
          args: Prisma.DriverLicenseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DriverLicenseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DriverLicenseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>[]
        }
        upsert: {
          args: Prisma.DriverLicenseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DriverLicensePayload>
        }
        aggregate: {
          args: Prisma.DriverLicenseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDriverLicense>
        }
        groupBy: {
          args: Prisma.DriverLicenseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DriverLicenseGroupByOutputType>[]
        }
        count: {
          args: Prisma.DriverLicenseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DriverLicenseCountAggregateOutputType> | number
        }
      }
    }
    CustomerViolation: {
      payload: Prisma.$CustomerViolationPayload<ExtArgs>
      fields: Prisma.CustomerViolationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomerViolationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomerViolationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>
        }
        findFirst: {
          args: Prisma.CustomerViolationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomerViolationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>
        }
        findMany: {
          args: Prisma.CustomerViolationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>[]
        }
        create: {
          args: Prisma.CustomerViolationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>
        }
        createMany: {
          args: Prisma.CustomerViolationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomerViolationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>[]
        }
        delete: {
          args: Prisma.CustomerViolationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>
        }
        update: {
          args: Prisma.CustomerViolationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>
        }
        deleteMany: {
          args: Prisma.CustomerViolationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomerViolationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomerViolationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>[]
        }
        upsert: {
          args: Prisma.CustomerViolationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomerViolationPayload>
        }
        aggregate: {
          args: Prisma.CustomerViolationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomerViolation>
        }
        groupBy: {
          args: Prisma.CustomerViolationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerViolationGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomerViolationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomerViolationCountAggregateOutputType> | number
        }
      }
    }
    RentalAgreement: {
      payload: Prisma.$RentalAgreementPayload<ExtArgs>
      fields: Prisma.RentalAgreementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentalAgreementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentalAgreementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>
        }
        findFirst: {
          args: Prisma.RentalAgreementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentalAgreementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>
        }
        findMany: {
          args: Prisma.RentalAgreementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>[]
        }
        create: {
          args: Prisma.RentalAgreementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>
        }
        createMany: {
          args: Prisma.RentalAgreementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentalAgreementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>[]
        }
        delete: {
          args: Prisma.RentalAgreementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>
        }
        update: {
          args: Prisma.RentalAgreementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>
        }
        deleteMany: {
          args: Prisma.RentalAgreementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentalAgreementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentalAgreementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>[]
        }
        upsert: {
          args: Prisma.RentalAgreementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalAgreementPayload>
        }
        aggregate: {
          args: Prisma.RentalAgreementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentalAgreement>
        }
        groupBy: {
          args: Prisma.RentalAgreementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalAgreementGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentalAgreementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalAgreementCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    PaymentReceipt: {
      payload: Prisma.$PaymentReceiptPayload<ExtArgs>
      fields: Prisma.PaymentReceiptFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentReceiptFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentReceiptFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>
        }
        findFirst: {
          args: Prisma.PaymentReceiptFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentReceiptFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>
        }
        findMany: {
          args: Prisma.PaymentReceiptFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>[]
        }
        create: {
          args: Prisma.PaymentReceiptCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>
        }
        createMany: {
          args: Prisma.PaymentReceiptCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentReceiptCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>[]
        }
        delete: {
          args: Prisma.PaymentReceiptDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>
        }
        update: {
          args: Prisma.PaymentReceiptUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>
        }
        deleteMany: {
          args: Prisma.PaymentReceiptDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentReceiptUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentReceiptUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>[]
        }
        upsert: {
          args: Prisma.PaymentReceiptUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentReceiptPayload>
        }
        aggregate: {
          args: Prisma.PaymentReceiptAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentReceipt>
        }
        groupBy: {
          args: Prisma.PaymentReceiptGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentReceiptGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentReceiptCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentReceiptCountAggregateOutputType> | number
        }
      }
    }
    CaribbeanCountry: {
      payload: Prisma.$CaribbeanCountryPayload<ExtArgs>
      fields: Prisma.CaribbeanCountryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CaribbeanCountryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CaribbeanCountryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>
        }
        findFirst: {
          args: Prisma.CaribbeanCountryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CaribbeanCountryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>
        }
        findMany: {
          args: Prisma.CaribbeanCountryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>[]
        }
        create: {
          args: Prisma.CaribbeanCountryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>
        }
        createMany: {
          args: Prisma.CaribbeanCountryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CaribbeanCountryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>[]
        }
        delete: {
          args: Prisma.CaribbeanCountryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>
        }
        update: {
          args: Prisma.CaribbeanCountryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>
        }
        deleteMany: {
          args: Prisma.CaribbeanCountryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CaribbeanCountryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CaribbeanCountryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>[]
        }
        upsert: {
          args: Prisma.CaribbeanCountryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CaribbeanCountryPayload>
        }
        aggregate: {
          args: Prisma.CaribbeanCountryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCaribbeanCountry>
        }
        groupBy: {
          args: Prisma.CaribbeanCountryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CaribbeanCountryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CaribbeanCountryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CaribbeanCountryCountAggregateOutputType> | number
        }
      }
    }
    ShopDMMerchant: {
      payload: Prisma.$ShopDMMerchantPayload<ExtArgs>
      fields: Prisma.ShopDMMerchantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ShopDMMerchantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ShopDMMerchantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>
        }
        findFirst: {
          args: Prisma.ShopDMMerchantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ShopDMMerchantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>
        }
        findMany: {
          args: Prisma.ShopDMMerchantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>[]
        }
        create: {
          args: Prisma.ShopDMMerchantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>
        }
        createMany: {
          args: Prisma.ShopDMMerchantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ShopDMMerchantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>[]
        }
        delete: {
          args: Prisma.ShopDMMerchantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>
        }
        update: {
          args: Prisma.ShopDMMerchantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>
        }
        deleteMany: {
          args: Prisma.ShopDMMerchantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ShopDMMerchantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ShopDMMerchantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>[]
        }
        upsert: {
          args: Prisma.ShopDMMerchantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ShopDMMerchantPayload>
        }
        aggregate: {
          args: Prisma.ShopDMMerchantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateShopDMMerchant>
        }
        groupBy: {
          args: Prisma.ShopDMMerchantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ShopDMMerchantGroupByOutputType>[]
        }
        count: {
          args: Prisma.ShopDMMerchantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ShopDMMerchantCountAggregateOutputType> | number
        }
      }
    }
    Currency: {
      payload: Prisma.$CurrencyPayload<ExtArgs>
      fields: Prisma.CurrencyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        findFirst: {
          args: Prisma.CurrencyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        findMany: {
          args: Prisma.CurrencyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        create: {
          args: Prisma.CurrencyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        createMany: {
          args: Prisma.CurrencyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        delete: {
          args: Prisma.CurrencyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        update: {
          args: Prisma.CurrencyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        deleteMany: {
          args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        upsert: {
          args: Prisma.CurrencyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        aggregate: {
          args: Prisma.CurrencyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCurrency>
        }
        groupBy: {
          args: Prisma.CurrencyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CurrencyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CurrencyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CurrencyCountAggregateOutputType> | number
        }
      }
    }
    TenantCurrencyRate: {
      payload: Prisma.$TenantCurrencyRatePayload<ExtArgs>
      fields: Prisma.TenantCurrencyRateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantCurrencyRateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantCurrencyRateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>
        }
        findFirst: {
          args: Prisma.TenantCurrencyRateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantCurrencyRateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>
        }
        findMany: {
          args: Prisma.TenantCurrencyRateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>[]
        }
        create: {
          args: Prisma.TenantCurrencyRateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>
        }
        createMany: {
          args: Prisma.TenantCurrencyRateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantCurrencyRateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>[]
        }
        delete: {
          args: Prisma.TenantCurrencyRateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>
        }
        update: {
          args: Prisma.TenantCurrencyRateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>
        }
        deleteMany: {
          args: Prisma.TenantCurrencyRateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantCurrencyRateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantCurrencyRateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>[]
        }
        upsert: {
          args: Prisma.TenantCurrencyRateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantCurrencyRatePayload>
        }
        aggregate: {
          args: Prisma.TenantCurrencyRateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantCurrencyRate>
        }
        groupBy: {
          args: Prisma.TenantCurrencyRateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCurrencyRateGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantCurrencyRateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCurrencyRateCountAggregateOutputType> | number
        }
      }
    }
    ExchangeRate: {
      payload: Prisma.$ExchangeRatePayload<ExtArgs>
      fields: Prisma.ExchangeRateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExchangeRateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExchangeRateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        findFirst: {
          args: Prisma.ExchangeRateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExchangeRateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        findMany: {
          args: Prisma.ExchangeRateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        create: {
          args: Prisma.ExchangeRateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        createMany: {
          args: Prisma.ExchangeRateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExchangeRateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        delete: {
          args: Prisma.ExchangeRateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        update: {
          args: Prisma.ExchangeRateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        deleteMany: {
          args: Prisma.ExchangeRateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExchangeRateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExchangeRateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        upsert: {
          args: Prisma.ExchangeRateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        aggregate: {
          args: Prisma.ExchangeRateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExchangeRate>
        }
        groupBy: {
          args: Prisma.ExchangeRateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExchangeRateGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExchangeRateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExchangeRateCountAggregateOutputType> | number
        }
      }
    }
    Form: {
      payload: Prisma.$FormPayload<ExtArgs>
      fields: Prisma.FormFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FormFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        findFirst: {
          args: Prisma.FormFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        findMany: {
          args: Prisma.FormFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>[]
        }
        create: {
          args: Prisma.FormCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        createMany: {
          args: Prisma.FormCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FormCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>[]
        }
        delete: {
          args: Prisma.FormDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        update: {
          args: Prisma.FormUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        deleteMany: {
          args: Prisma.FormDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FormUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FormUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>[]
        }
        upsert: {
          args: Prisma.FormUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        aggregate: {
          args: Prisma.FormAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForm>
        }
        groupBy: {
          args: Prisma.FormGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormGroupByOutputType>[]
        }
        count: {
          args: Prisma.FormCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormCountAggregateOutputType> | number
        }
      }
    }
    FormResponse: {
      payload: Prisma.$FormResponsePayload<ExtArgs>
      fields: Prisma.FormResponseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FormResponseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FormResponseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>
        }
        findFirst: {
          args: Prisma.FormResponseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FormResponseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>
        }
        findMany: {
          args: Prisma.FormResponseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
        }
        create: {
          args: Prisma.FormResponseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>
        }
        createMany: {
          args: Prisma.FormResponseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FormResponseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
        }
        delete: {
          args: Prisma.FormResponseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>
        }
        update: {
          args: Prisma.FormResponseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>
        }
        deleteMany: {
          args: Prisma.FormResponseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FormResponseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FormResponseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>[]
        }
        upsert: {
          args: Prisma.FormResponseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormResponsePayload>
        }
        aggregate: {
          args: Prisma.FormResponseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFormResponse>
        }
        groupBy: {
          args: Prisma.FormResponseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormResponseGroupByOutputType>[]
        }
        count: {
          args: Prisma.FormResponseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormResponseCountAggregateOutputType> | number
        }
      }
    }
    RentalActivity: {
      payload: Prisma.$RentalActivityPayload<ExtArgs>
      fields: Prisma.RentalActivityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentalActivityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentalActivityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>
        }
        findFirst: {
          args: Prisma.RentalActivityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentalActivityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>
        }
        findMany: {
          args: Prisma.RentalActivityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>[]
        }
        create: {
          args: Prisma.RentalActivityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>
        }
        createMany: {
          args: Prisma.RentalActivityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentalActivityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>[]
        }
        delete: {
          args: Prisma.RentalActivityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>
        }
        update: {
          args: Prisma.RentalActivityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>
        }
        deleteMany: {
          args: Prisma.RentalActivityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentalActivityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentalActivityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>[]
        }
        upsert: {
          args: Prisma.RentalActivityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalActivityPayload>
        }
        aggregate: {
          args: Prisma.RentalActivityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentalActivity>
        }
        groupBy: {
          args: Prisma.RentalActivityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalActivityGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentalActivityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalActivityCountAggregateOutputType> | number
        }
      }
    }
    TenantNotification: {
      payload: Prisma.$TenantNotificationPayload<ExtArgs>
      fields: Prisma.TenantNotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantNotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantNotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>
        }
        findFirst: {
          args: Prisma.TenantNotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantNotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>
        }
        findMany: {
          args: Prisma.TenantNotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>[]
        }
        create: {
          args: Prisma.TenantNotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>
        }
        createMany: {
          args: Prisma.TenantNotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantNotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>[]
        }
        delete: {
          args: Prisma.TenantNotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>
        }
        update: {
          args: Prisma.TenantNotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>
        }
        deleteMany: {
          args: Prisma.TenantNotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantNotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantNotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>[]
        }
        upsert: {
          args: Prisma.TenantNotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantNotificationPayload>
        }
        aggregate: {
          args: Prisma.TenantNotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantNotification>
        }
        groupBy: {
          args: Prisma.TenantNotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantNotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantNotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantNotificationCountAggregateOutputType> | number
        }
      }
    }
    NotificationReadStatus: {
      payload: Prisma.$NotificationReadStatusPayload<ExtArgs>
      fields: Prisma.NotificationReadStatusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationReadStatusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationReadStatusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>
        }
        findFirst: {
          args: Prisma.NotificationReadStatusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationReadStatusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>
        }
        findMany: {
          args: Prisma.NotificationReadStatusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>[]
        }
        create: {
          args: Prisma.NotificationReadStatusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>
        }
        createMany: {
          args: Prisma.NotificationReadStatusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationReadStatusCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>[]
        }
        delete: {
          args: Prisma.NotificationReadStatusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>
        }
        update: {
          args: Prisma.NotificationReadStatusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>
        }
        deleteMany: {
          args: Prisma.NotificationReadStatusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationReadStatusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationReadStatusUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>[]
        }
        upsert: {
          args: Prisma.NotificationReadStatusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationReadStatusPayload>
        }
        aggregate: {
          args: Prisma.NotificationReadStatusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotificationReadStatus>
        }
        groupBy: {
          args: Prisma.NotificationReadStatusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationReadStatusGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationReadStatusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationReadStatusCountAggregateOutputType> | number
        }
      }
    }
    AppPermission: {
      payload: Prisma.$AppPermissionPayload<ExtArgs>
      fields: Prisma.AppPermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AppPermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AppPermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>
        }
        findFirst: {
          args: Prisma.AppPermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AppPermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>
        }
        findMany: {
          args: Prisma.AppPermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>[]
        }
        create: {
          args: Prisma.AppPermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>
        }
        createMany: {
          args: Prisma.AppPermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AppPermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>[]
        }
        delete: {
          args: Prisma.AppPermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>
        }
        update: {
          args: Prisma.AppPermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>
        }
        deleteMany: {
          args: Prisma.AppPermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AppPermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AppPermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>[]
        }
        upsert: {
          args: Prisma.AppPermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppPermissionPayload>
        }
        aggregate: {
          args: Prisma.AppPermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppPermission>
        }
        groupBy: {
          args: Prisma.AppPermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppPermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.AppPermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppPermissionCountAggregateOutputType> | number
        }
      }
    }
    PermissionCategory: {
      payload: Prisma.$PermissionCategoryPayload<ExtArgs>
      fields: Prisma.PermissionCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
        }
        findFirst: {
          args: Prisma.PermissionCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
        }
        findMany: {
          args: Prisma.PermissionCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>[]
        }
        create: {
          args: Prisma.PermissionCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
        }
        createMany: {
          args: Prisma.PermissionCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>[]
        }
        delete: {
          args: Prisma.PermissionCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
        }
        update: {
          args: Prisma.PermissionCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
        }
        deleteMany: {
          args: Prisma.PermissionCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>[]
        }
        upsert: {
          args: Prisma.PermissionCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionCategoryPayload>
        }
        aggregate: {
          args: Prisma.PermissionCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermissionCategory>
        }
        groupBy: {
          args: Prisma.PermissionCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionCategoryCountAggregateOutputType> | number
        }
      }
    }
    Rental: {
      payload: Prisma.$RentalPayload<ExtArgs>
      fields: Prisma.RentalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>
        }
        findFirst: {
          args: Prisma.RentalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>
        }
        findMany: {
          args: Prisma.RentalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>[]
        }
        create: {
          args: Prisma.RentalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>
        }
        createMany: {
          args: Prisma.RentalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>[]
        }
        delete: {
          args: Prisma.RentalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>
        }
        update: {
          args: Prisma.RentalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>
        }
        deleteMany: {
          args: Prisma.RentalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>[]
        }
        upsert: {
          args: Prisma.RentalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalPayload>
        }
        aggregate: {
          args: Prisma.RentalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRental>
        }
        groupBy: {
          args: Prisma.RentalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalCountAggregateOutputType> | number
        }
      }
    }
    StorefrontBooking: {
      payload: Prisma.$StorefrontBookingPayload<ExtArgs>
      fields: Prisma.StorefrontBookingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StorefrontBookingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StorefrontBookingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>
        }
        findFirst: {
          args: Prisma.StorefrontBookingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StorefrontBookingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>
        }
        findMany: {
          args: Prisma.StorefrontBookingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>[]
        }
        create: {
          args: Prisma.StorefrontBookingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>
        }
        createMany: {
          args: Prisma.StorefrontBookingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StorefrontBookingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>[]
        }
        delete: {
          args: Prisma.StorefrontBookingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>
        }
        update: {
          args: Prisma.StorefrontBookingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>
        }
        deleteMany: {
          args: Prisma.StorefrontBookingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StorefrontBookingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StorefrontBookingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>[]
        }
        upsert: {
          args: Prisma.StorefrontBookingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontBookingPayload>
        }
        aggregate: {
          args: Prisma.StorefrontBookingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStorefrontBooking>
        }
        groupBy: {
          args: Prisma.StorefrontBookingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StorefrontBookingGroupByOutputType>[]
        }
        count: {
          args: Prisma.StorefrontBookingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StorefrontBookingCountAggregateOutputType> | number
        }
      }
    }
    RentalDriver: {
      payload: Prisma.$RentalDriverPayload<ExtArgs>
      fields: Prisma.RentalDriverFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentalDriverFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentalDriverFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>
        }
        findFirst: {
          args: Prisma.RentalDriverFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentalDriverFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>
        }
        findMany: {
          args: Prisma.RentalDriverFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>[]
        }
        create: {
          args: Prisma.RentalDriverCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>
        }
        createMany: {
          args: Prisma.RentalDriverCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentalDriverCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>[]
        }
        delete: {
          args: Prisma.RentalDriverDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>
        }
        update: {
          args: Prisma.RentalDriverUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>
        }
        deleteMany: {
          args: Prisma.RentalDriverDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentalDriverUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentalDriverUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>[]
        }
        upsert: {
          args: Prisma.RentalDriverUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalDriverPayload>
        }
        aggregate: {
          args: Prisma.RentalDriverAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentalDriver>
        }
        groupBy: {
          args: Prisma.RentalDriverGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalDriverGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentalDriverCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalDriverCountAggregateOutputType> | number
        }
      }
    }
    Values: {
      payload: Prisma.$ValuesPayload<ExtArgs>
      fields: Prisma.ValuesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ValuesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ValuesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>
        }
        findFirst: {
          args: Prisma.ValuesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ValuesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>
        }
        findMany: {
          args: Prisma.ValuesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>[]
        }
        create: {
          args: Prisma.ValuesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>
        }
        createMany: {
          args: Prisma.ValuesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ValuesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>[]
        }
        delete: {
          args: Prisma.ValuesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>
        }
        update: {
          args: Prisma.ValuesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>
        }
        deleteMany: {
          args: Prisma.ValuesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ValuesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ValuesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>[]
        }
        upsert: {
          args: Prisma.ValuesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ValuesPayload>
        }
        aggregate: {
          args: Prisma.ValuesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateValues>
        }
        groupBy: {
          args: Prisma.ValuesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ValuesGroupByOutputType>[]
        }
        count: {
          args: Prisma.ValuesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ValuesCountAggregateOutputType> | number
        }
      }
    }
    RentalExtra: {
      payload: Prisma.$RentalExtraPayload<ExtArgs>
      fields: Prisma.RentalExtraFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentalExtraFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentalExtraFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>
        }
        findFirst: {
          args: Prisma.RentalExtraFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentalExtraFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>
        }
        findMany: {
          args: Prisma.RentalExtraFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>[]
        }
        create: {
          args: Prisma.RentalExtraCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>
        }
        createMany: {
          args: Prisma.RentalExtraCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentalExtraCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>[]
        }
        delete: {
          args: Prisma.RentalExtraDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>
        }
        update: {
          args: Prisma.RentalExtraUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>
        }
        deleteMany: {
          args: Prisma.RentalExtraDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentalExtraUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentalExtraUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>[]
        }
        upsert: {
          args: Prisma.RentalExtraUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalExtraPayload>
        }
        aggregate: {
          args: Prisma.RentalExtraAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentalExtra>
        }
        groupBy: {
          args: Prisma.RentalExtraGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalExtraGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentalExtraCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalExtraCountAggregateOutputType> | number
        }
      }
    }
    RentalCharge: {
      payload: Prisma.$RentalChargePayload<ExtArgs>
      fields: Prisma.RentalChargeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentalChargeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentalChargeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>
        }
        findFirst: {
          args: Prisma.RentalChargeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentalChargeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>
        }
        findMany: {
          args: Prisma.RentalChargeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>[]
        }
        create: {
          args: Prisma.RentalChargeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>
        }
        createMany: {
          args: Prisma.RentalChargeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentalChargeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>[]
        }
        delete: {
          args: Prisma.RentalChargeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>
        }
        update: {
          args: Prisma.RentalChargeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>
        }
        deleteMany: {
          args: Prisma.RentalChargeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentalChargeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentalChargeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>[]
        }
        upsert: {
          args: Prisma.RentalChargeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentalChargePayload>
        }
        aggregate: {
          args: Prisma.RentalChargeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentalCharge>
        }
        groupBy: {
          args: Prisma.RentalChargeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalChargeGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentalChargeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentalChargeCountAggregateOutputType> | number
        }
      }
    }
    VesselInfo: {
      payload: Prisma.$VesselInfoPayload<ExtArgs>
      fields: Prisma.VesselInfoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VesselInfoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VesselInfoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>
        }
        findFirst: {
          args: Prisma.VesselInfoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VesselInfoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>
        }
        findMany: {
          args: Prisma.VesselInfoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>[]
        }
        create: {
          args: Prisma.VesselInfoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>
        }
        createMany: {
          args: Prisma.VesselInfoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VesselInfoCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>[]
        }
        delete: {
          args: Prisma.VesselInfoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>
        }
        update: {
          args: Prisma.VesselInfoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>
        }
        deleteMany: {
          args: Prisma.VesselInfoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VesselInfoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VesselInfoUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>[]
        }
        upsert: {
          args: Prisma.VesselInfoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VesselInfoPayload>
        }
        aggregate: {
          args: Prisma.VesselInfoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVesselInfo>
        }
        groupBy: {
          args: Prisma.VesselInfoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VesselInfoGroupByOutputType>[]
        }
        count: {
          args: Prisma.VesselInfoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VesselInfoCountAggregateOutputType> | number
        }
      }
    }
    TenantWeeklyStats: {
      payload: Prisma.$TenantWeeklyStatsPayload<ExtArgs>
      fields: Prisma.TenantWeeklyStatsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantWeeklyStatsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantWeeklyStatsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>
        }
        findFirst: {
          args: Prisma.TenantWeeklyStatsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantWeeklyStatsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>
        }
        findMany: {
          args: Prisma.TenantWeeklyStatsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>[]
        }
        create: {
          args: Prisma.TenantWeeklyStatsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>
        }
        createMany: {
          args: Prisma.TenantWeeklyStatsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantWeeklyStatsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>[]
        }
        delete: {
          args: Prisma.TenantWeeklyStatsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>
        }
        update: {
          args: Prisma.TenantWeeklyStatsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>
        }
        deleteMany: {
          args: Prisma.TenantWeeklyStatsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantWeeklyStatsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantWeeklyStatsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>[]
        }
        upsert: {
          args: Prisma.TenantWeeklyStatsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantWeeklyStatsPayload>
        }
        aggregate: {
          args: Prisma.TenantWeeklyStatsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantWeeklyStats>
        }
        groupBy: {
          args: Prisma.TenantWeeklyStatsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantWeeklyStatsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantWeeklyStatsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantWeeklyStatsCountAggregateOutputType> | number
        }
      }
    }
    TenantYearlyStats: {
      payload: Prisma.$TenantYearlyStatsPayload<ExtArgs>
      fields: Prisma.TenantYearlyStatsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantYearlyStatsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantYearlyStatsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>
        }
        findFirst: {
          args: Prisma.TenantYearlyStatsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantYearlyStatsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>
        }
        findMany: {
          args: Prisma.TenantYearlyStatsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>[]
        }
        create: {
          args: Prisma.TenantYearlyStatsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>
        }
        createMany: {
          args: Prisma.TenantYearlyStatsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantYearlyStatsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>[]
        }
        delete: {
          args: Prisma.TenantYearlyStatsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>
        }
        update: {
          args: Prisma.TenantYearlyStatsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>
        }
        deleteMany: {
          args: Prisma.TenantYearlyStatsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantYearlyStatsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantYearlyStatsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>[]
        }
        upsert: {
          args: Prisma.TenantYearlyStatsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantYearlyStatsPayload>
        }
        aggregate: {
          args: Prisma.TenantYearlyStatsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantYearlyStats>
        }
        groupBy: {
          args: Prisma.TenantYearlyStatsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantYearlyStatsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantYearlyStatsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantYearlyStatsCountAggregateOutputType> | number
        }
      }
    }
    TenantMonthlyStats: {
      payload: Prisma.$TenantMonthlyStatsPayload<ExtArgs>
      fields: Prisma.TenantMonthlyStatsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantMonthlyStatsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantMonthlyStatsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>
        }
        findFirst: {
          args: Prisma.TenantMonthlyStatsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantMonthlyStatsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>
        }
        findMany: {
          args: Prisma.TenantMonthlyStatsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>[]
        }
        create: {
          args: Prisma.TenantMonthlyStatsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>
        }
        createMany: {
          args: Prisma.TenantMonthlyStatsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantMonthlyStatsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>[]
        }
        delete: {
          args: Prisma.TenantMonthlyStatsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>
        }
        update: {
          args: Prisma.TenantMonthlyStatsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>
        }
        deleteMany: {
          args: Prisma.TenantMonthlyStatsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantMonthlyStatsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantMonthlyStatsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>[]
        }
        upsert: {
          args: Prisma.TenantMonthlyStatsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyStatsPayload>
        }
        aggregate: {
          args: Prisma.TenantMonthlyStatsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantMonthlyStats>
        }
        groupBy: {
          args: Prisma.TenantMonthlyStatsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantMonthlyStatsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantMonthlyStatsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantMonthlyStatsCountAggregateOutputType> | number
        }
      }
    }
    TenantMonthlyRentalStats: {
      payload: Prisma.$TenantMonthlyRentalStatsPayload<ExtArgs>
      fields: Prisma.TenantMonthlyRentalStatsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantMonthlyRentalStatsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantMonthlyRentalStatsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>
        }
        findFirst: {
          args: Prisma.TenantMonthlyRentalStatsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantMonthlyRentalStatsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>
        }
        findMany: {
          args: Prisma.TenantMonthlyRentalStatsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>[]
        }
        create: {
          args: Prisma.TenantMonthlyRentalStatsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>
        }
        createMany: {
          args: Prisma.TenantMonthlyRentalStatsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantMonthlyRentalStatsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>[]
        }
        delete: {
          args: Prisma.TenantMonthlyRentalStatsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>
        }
        update: {
          args: Prisma.TenantMonthlyRentalStatsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>
        }
        deleteMany: {
          args: Prisma.TenantMonthlyRentalStatsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantMonthlyRentalStatsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantMonthlyRentalStatsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>[]
        }
        upsert: {
          args: Prisma.TenantMonthlyRentalStatsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantMonthlyRentalStatsPayload>
        }
        aggregate: {
          args: Prisma.TenantMonthlyRentalStatsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantMonthlyRentalStats>
        }
        groupBy: {
          args: Prisma.TenantMonthlyRentalStatsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantMonthlyRentalStatsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantMonthlyRentalStatsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantMonthlyRentalStatsCountAggregateOutputType> | number
        }
      }
    }
    TenantRatings: {
      payload: Prisma.$TenantRatingsPayload<ExtArgs>
      fields: Prisma.TenantRatingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantRatingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantRatingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>
        }
        findFirst: {
          args: Prisma.TenantRatingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantRatingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>
        }
        findMany: {
          args: Prisma.TenantRatingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>[]
        }
        create: {
          args: Prisma.TenantRatingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>
        }
        createMany: {
          args: Prisma.TenantRatingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantRatingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>[]
        }
        delete: {
          args: Prisma.TenantRatingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>
        }
        update: {
          args: Prisma.TenantRatingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>
        }
        deleteMany: {
          args: Prisma.TenantRatingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantRatingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantRatingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>[]
        }
        upsert: {
          args: Prisma.TenantRatingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRatingsPayload>
        }
        aggregate: {
          args: Prisma.TenantRatingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantRatings>
        }
        groupBy: {
          args: Prisma.TenantRatingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantRatingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantRatingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantRatingsCountAggregateOutputType> | number
        }
      }
    }
    SiteRatings: {
      payload: Prisma.$SiteRatingsPayload<ExtArgs>
      fields: Prisma.SiteRatingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SiteRatingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SiteRatingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>
        }
        findFirst: {
          args: Prisma.SiteRatingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SiteRatingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>
        }
        findMany: {
          args: Prisma.SiteRatingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>[]
        }
        create: {
          args: Prisma.SiteRatingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>
        }
        createMany: {
          args: Prisma.SiteRatingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SiteRatingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>[]
        }
        delete: {
          args: Prisma.SiteRatingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>
        }
        update: {
          args: Prisma.SiteRatingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>
        }
        deleteMany: {
          args: Prisma.SiteRatingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SiteRatingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SiteRatingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>[]
        }
        upsert: {
          args: Prisma.SiteRatingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SiteRatingsPayload>
        }
        aggregate: {
          args: Prisma.SiteRatingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSiteRatings>
        }
        groupBy: {
          args: Prisma.SiteRatingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SiteRatingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.SiteRatingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SiteRatingsCountAggregateOutputType> | number
        }
      }
    }
    SubscriptionPlan: {
      payload: Prisma.$SubscriptionPlanPayload<ExtArgs>
      fields: Prisma.SubscriptionPlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        findFirst: {
          args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        findMany: {
          args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
        }
        create: {
          args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        createMany: {
          args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
        }
        delete: {
          args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        update: {
          args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        deleteMany: {
          args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[]
        }
        upsert: {
          args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>
        }
        aggregate: {
          args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSubscriptionPlan>
        }
        groupBy: {
          args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionPlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.SubscriptionPlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SubscriptionPlanCountAggregateOutputType> | number
        }
      }
    }
    PlanFeatures: {
      payload: Prisma.$PlanFeaturesPayload<ExtArgs>
      fields: Prisma.PlanFeaturesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlanFeaturesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlanFeaturesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>
        }
        findFirst: {
          args: Prisma.PlanFeaturesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlanFeaturesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>
        }
        findMany: {
          args: Prisma.PlanFeaturesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>[]
        }
        create: {
          args: Prisma.PlanFeaturesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>
        }
        createMany: {
          args: Prisma.PlanFeaturesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlanFeaturesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>[]
        }
        delete: {
          args: Prisma.PlanFeaturesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>
        }
        update: {
          args: Prisma.PlanFeaturesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>
        }
        deleteMany: {
          args: Prisma.PlanFeaturesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlanFeaturesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlanFeaturesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>[]
        }
        upsert: {
          args: Prisma.PlanFeaturesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanFeaturesPayload>
        }
        aggregate: {
          args: Prisma.PlanFeaturesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlanFeatures>
        }
        groupBy: {
          args: Prisma.PlanFeaturesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlanFeaturesGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlanFeaturesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlanFeaturesCountAggregateOutputType> | number
        }
      }
    }
    PlanDetails: {
      payload: Prisma.$PlanDetailsPayload<ExtArgs>
      fields: Prisma.PlanDetailsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PlanDetailsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PlanDetailsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>
        }
        findFirst: {
          args: Prisma.PlanDetailsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PlanDetailsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>
        }
        findMany: {
          args: Prisma.PlanDetailsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>[]
        }
        create: {
          args: Prisma.PlanDetailsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>
        }
        createMany: {
          args: Prisma.PlanDetailsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PlanDetailsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>[]
        }
        delete: {
          args: Prisma.PlanDetailsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>
        }
        update: {
          args: Prisma.PlanDetailsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>
        }
        deleteMany: {
          args: Prisma.PlanDetailsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PlanDetailsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PlanDetailsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>[]
        }
        upsert: {
          args: Prisma.PlanDetailsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PlanDetailsPayload>
        }
        aggregate: {
          args: Prisma.PlanDetailsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePlanDetails>
        }
        groupBy: {
          args: Prisma.PlanDetailsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlanDetailsGroupByOutputType>[]
        }
        count: {
          args: Prisma.PlanDetailsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PlanDetailsCountAggregateOutputType> | number
        }
      }
    }
    Tenant: {
      payload: Prisma.$TenantPayload<ExtArgs>
      fields: Prisma.TenantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findFirst: {
          args: Prisma.TenantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        findMany: {
          args: Prisma.TenantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        create: {
          args: Prisma.TenantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        createMany: {
          args: Prisma.TenantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        delete: {
          args: Prisma.TenantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        update: {
          args: Prisma.TenantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        deleteMany: {
          args: Prisma.TenantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[]
        }
        upsert: {
          args: Prisma.TenantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>
        }
        aggregate: {
          args: Prisma.TenantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenant>
        }
        groupBy: {
          args: Prisma.TenantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantCountAggregateOutputType> | number
        }
      }
    }
    EmailVerification: {
      payload: Prisma.$EmailVerificationPayload<ExtArgs>
      fields: Prisma.EmailVerificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailVerificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailVerificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
        }
        findFirst: {
          args: Prisma.EmailVerificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailVerificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
        }
        findMany: {
          args: Prisma.EmailVerificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
        }
        create: {
          args: Prisma.EmailVerificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
        }
        createMany: {
          args: Prisma.EmailVerificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmailVerificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
        }
        delete: {
          args: Prisma.EmailVerificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
        }
        update: {
          args: Prisma.EmailVerificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
        }
        deleteMany: {
          args: Prisma.EmailVerificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailVerificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmailVerificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
        }
        upsert: {
          args: Prisma.EmailVerificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
        }
        aggregate: {
          args: Prisma.EmailVerificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailVerification>
        }
        groupBy: {
          args: Prisma.EmailVerificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailVerificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailVerificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailVerificationCountAggregateOutputType> | number
        }
      }
    }
    PaymentMethod: {
      payload: Prisma.$PaymentMethodPayload<ExtArgs>
      fields: Prisma.PaymentMethodFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentMethodFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentMethodFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        findFirst: {
          args: Prisma.PaymentMethodFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentMethodFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        findMany: {
          args: Prisma.PaymentMethodFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
        }
        create: {
          args: Prisma.PaymentMethodCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        createMany: {
          args: Prisma.PaymentMethodCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentMethodCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
        }
        delete: {
          args: Prisma.PaymentMethodDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        update: {
          args: Prisma.PaymentMethodUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        deleteMany: {
          args: Prisma.PaymentMethodDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentMethodUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentMethodUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>[]
        }
        upsert: {
          args: Prisma.PaymentMethodUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentMethodPayload>
        }
        aggregate: {
          args: Prisma.PaymentMethodAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePaymentMethod>
        }
        groupBy: {
          args: Prisma.PaymentMethodGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentMethodCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentMethodCountAggregateOutputType> | number
        }
      }
    }
    Address: {
      payload: Prisma.$AddressPayload<ExtArgs>
      fields: Prisma.AddressFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AddressFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        findFirst: {
          args: Prisma.AddressFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        findMany: {
          args: Prisma.AddressFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>[]
        }
        create: {
          args: Prisma.AddressCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        createMany: {
          args: Prisma.AddressCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>[]
        }
        delete: {
          args: Prisma.AddressDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        update: {
          args: Prisma.AddressUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        deleteMany: {
          args: Prisma.AddressDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AddressUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>[]
        }
        upsert: {
          args: Prisma.AddressUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AddressPayload>
        }
        aggregate: {
          args: Prisma.AddressAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAddress>
        }
        groupBy: {
          args: Prisma.AddressGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AddressGroupByOutputType>[]
        }
        count: {
          args: Prisma.AddressCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AddressCountAggregateOutputType> | number
        }
      }
    }
    TenantLocation: {
      payload: Prisma.$TenantLocationPayload<ExtArgs>
      fields: Prisma.TenantLocationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantLocationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantLocationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>
        }
        findFirst: {
          args: Prisma.TenantLocationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantLocationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>
        }
        findMany: {
          args: Prisma.TenantLocationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>[]
        }
        create: {
          args: Prisma.TenantLocationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>
        }
        createMany: {
          args: Prisma.TenantLocationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantLocationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>[]
        }
        delete: {
          args: Prisma.TenantLocationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>
        }
        update: {
          args: Prisma.TenantLocationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>
        }
        deleteMany: {
          args: Prisma.TenantLocationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantLocationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantLocationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>[]
        }
        upsert: {
          args: Prisma.TenantLocationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantLocationPayload>
        }
        aggregate: {
          args: Prisma.TenantLocationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantLocation>
        }
        groupBy: {
          args: Prisma.TenantLocationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantLocationGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantLocationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantLocationCountAggregateOutputType> | number
        }
      }
    }
    TenantInsurance: {
      payload: Prisma.$TenantInsurancePayload<ExtArgs>
      fields: Prisma.TenantInsuranceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantInsuranceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantInsuranceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>
        }
        findFirst: {
          args: Prisma.TenantInsuranceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantInsuranceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>
        }
        findMany: {
          args: Prisma.TenantInsuranceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>[]
        }
        create: {
          args: Prisma.TenantInsuranceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>
        }
        createMany: {
          args: Prisma.TenantInsuranceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantInsuranceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>[]
        }
        delete: {
          args: Prisma.TenantInsuranceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>
        }
        update: {
          args: Prisma.TenantInsuranceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>
        }
        deleteMany: {
          args: Prisma.TenantInsuranceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantInsuranceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantInsuranceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>[]
        }
        upsert: {
          args: Prisma.TenantInsuranceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantInsurancePayload>
        }
        aggregate: {
          args: Prisma.TenantInsuranceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantInsurance>
        }
        groupBy: {
          args: Prisma.TenantInsuranceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantInsuranceGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantInsuranceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantInsuranceCountAggregateOutputType> | number
        }
      }
    }
    TenantEquipment: {
      payload: Prisma.$TenantEquipmentPayload<ExtArgs>
      fields: Prisma.TenantEquipmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantEquipmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantEquipmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>
        }
        findFirst: {
          args: Prisma.TenantEquipmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantEquipmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>
        }
        findMany: {
          args: Prisma.TenantEquipmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>[]
        }
        create: {
          args: Prisma.TenantEquipmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>
        }
        createMany: {
          args: Prisma.TenantEquipmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantEquipmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>[]
        }
        delete: {
          args: Prisma.TenantEquipmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>
        }
        update: {
          args: Prisma.TenantEquipmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>
        }
        deleteMany: {
          args: Prisma.TenantEquipmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantEquipmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantEquipmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>[]
        }
        upsert: {
          args: Prisma.TenantEquipmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantEquipmentPayload>
        }
        aggregate: {
          args: Prisma.TenantEquipmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantEquipment>
        }
        groupBy: {
          args: Prisma.TenantEquipmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantEquipmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantEquipmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantEquipmentCountAggregateOutputType> | number
        }
      }
    }
    TenantService: {
      payload: Prisma.$TenantServicePayload<ExtArgs>
      fields: Prisma.TenantServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>
        }
        findFirst: {
          args: Prisma.TenantServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>
        }
        findMany: {
          args: Prisma.TenantServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>[]
        }
        create: {
          args: Prisma.TenantServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>
        }
        createMany: {
          args: Prisma.TenantServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>[]
        }
        delete: {
          args: Prisma.TenantServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>
        }
        update: {
          args: Prisma.TenantServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>
        }
        deleteMany: {
          args: Prisma.TenantServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>[]
        }
        upsert: {
          args: Prisma.TenantServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantServicePayload>
        }
        aggregate: {
          args: Prisma.TenantServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantService>
        }
        groupBy: {
          args: Prisma.TenantServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantServiceCountAggregateOutputType> | number
        }
      }
    }
    TenantSubscription: {
      payload: Prisma.$TenantSubscriptionPayload<ExtArgs>
      fields: Prisma.TenantSubscriptionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantSubscriptionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantSubscriptionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        findFirst: {
          args: Prisma.TenantSubscriptionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantSubscriptionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        findMany: {
          args: Prisma.TenantSubscriptionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>[]
        }
        create: {
          args: Prisma.TenantSubscriptionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        createMany: {
          args: Prisma.TenantSubscriptionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantSubscriptionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>[]
        }
        delete: {
          args: Prisma.TenantSubscriptionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        update: {
          args: Prisma.TenantSubscriptionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        deleteMany: {
          args: Prisma.TenantSubscriptionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantSubscriptionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantSubscriptionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>[]
        }
        upsert: {
          args: Prisma.TenantSubscriptionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantSubscriptionPayload>
        }
        aggregate: {
          args: Prisma.TenantSubscriptionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantSubscription>
        }
        groupBy: {
          args: Prisma.TenantSubscriptionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantSubscriptionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantSubscriptionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantSubscriptionCountAggregateOutputType> | number
        }
      }
    }
    TenantContact: {
      payload: Prisma.$TenantContactPayload<ExtArgs>
      fields: Prisma.TenantContactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantContactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantContactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>
        }
        findFirst: {
          args: Prisma.TenantContactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantContactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>
        }
        findMany: {
          args: Prisma.TenantContactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>[]
        }
        create: {
          args: Prisma.TenantContactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>
        }
        createMany: {
          args: Prisma.TenantContactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantContactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>[]
        }
        delete: {
          args: Prisma.TenantContactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>
        }
        update: {
          args: Prisma.TenantContactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>
        }
        deleteMany: {
          args: Prisma.TenantContactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantContactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantContactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>[]
        }
        upsert: {
          args: Prisma.TenantContactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantContactPayload>
        }
        aggregate: {
          args: Prisma.TenantContactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantContact>
        }
        groupBy: {
          args: Prisma.TenantContactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantContactGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantContactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantContactCountAggregateOutputType> | number
        }
      }
    }
    TenantReminders: {
      payload: Prisma.$TenantRemindersPayload<ExtArgs>
      fields: Prisma.TenantRemindersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantRemindersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantRemindersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>
        }
        findFirst: {
          args: Prisma.TenantRemindersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantRemindersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>
        }
        findMany: {
          args: Prisma.TenantRemindersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>[]
        }
        create: {
          args: Prisma.TenantRemindersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>
        }
        createMany: {
          args: Prisma.TenantRemindersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantRemindersCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>[]
        }
        delete: {
          args: Prisma.TenantRemindersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>
        }
        update: {
          args: Prisma.TenantRemindersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>
        }
        deleteMany: {
          args: Prisma.TenantRemindersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantRemindersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantRemindersUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>[]
        }
        upsert: {
          args: Prisma.TenantRemindersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantRemindersPayload>
        }
        aggregate: {
          args: Prisma.TenantRemindersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantReminders>
        }
        groupBy: {
          args: Prisma.TenantRemindersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantRemindersGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantRemindersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantRemindersCountAggregateOutputType> | number
        }
      }
    }
    CancellationPolicy: {
      payload: Prisma.$CancellationPolicyPayload<ExtArgs>
      fields: Prisma.CancellationPolicyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CancellationPolicyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CancellationPolicyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
        }
        findFirst: {
          args: Prisma.CancellationPolicyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CancellationPolicyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
        }
        findMany: {
          args: Prisma.CancellationPolicyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
        }
        create: {
          args: Prisma.CancellationPolicyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
        }
        createMany: {
          args: Prisma.CancellationPolicyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CancellationPolicyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
        }
        delete: {
          args: Prisma.CancellationPolicyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
        }
        update: {
          args: Prisma.CancellationPolicyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
        }
        deleteMany: {
          args: Prisma.CancellationPolicyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CancellationPolicyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CancellationPolicyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
        }
        upsert: {
          args: Prisma.CancellationPolicyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
        }
        aggregate: {
          args: Prisma.CancellationPolicyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCancellationPolicy>
        }
        groupBy: {
          args: Prisma.CancellationPolicyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CancellationPolicyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CancellationPolicyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CancellationPolicyCountAggregateOutputType> | number
        }
      }
    }
    LatePolicy: {
      payload: Prisma.$LatePolicyPayload<ExtArgs>
      fields: Prisma.LatePolicyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LatePolicyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LatePolicyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>
        }
        findFirst: {
          args: Prisma.LatePolicyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LatePolicyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>
        }
        findMany: {
          args: Prisma.LatePolicyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>[]
        }
        create: {
          args: Prisma.LatePolicyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>
        }
        createMany: {
          args: Prisma.LatePolicyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LatePolicyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>[]
        }
        delete: {
          args: Prisma.LatePolicyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>
        }
        update: {
          args: Prisma.LatePolicyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>
        }
        deleteMany: {
          args: Prisma.LatePolicyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LatePolicyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LatePolicyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>[]
        }
        upsert: {
          args: Prisma.LatePolicyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LatePolicyPayload>
        }
        aggregate: {
          args: Prisma.LatePolicyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLatePolicy>
        }
        groupBy: {
          args: Prisma.LatePolicyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LatePolicyGroupByOutputType>[]
        }
        count: {
          args: Prisma.LatePolicyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LatePolicyCountAggregateOutputType> | number
        }
      }
    }
    TenantViolation: {
      payload: Prisma.$TenantViolationPayload<ExtArgs>
      fields: Prisma.TenantViolationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantViolationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantViolationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>
        }
        findFirst: {
          args: Prisma.TenantViolationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantViolationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>
        }
        findMany: {
          args: Prisma.TenantViolationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>[]
        }
        create: {
          args: Prisma.TenantViolationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>
        }
        createMany: {
          args: Prisma.TenantViolationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantViolationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>[]
        }
        delete: {
          args: Prisma.TenantViolationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>
        }
        update: {
          args: Prisma.TenantViolationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>
        }
        deleteMany: {
          args: Prisma.TenantViolationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantViolationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantViolationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>[]
        }
        upsert: {
          args: Prisma.TenantViolationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantViolationPayload>
        }
        aggregate: {
          args: Prisma.TenantViolationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantViolation>
        }
        groupBy: {
          args: Prisma.TenantViolationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantViolationGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantViolationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantViolationCountAggregateOutputType> | number
        }
      }
    }
    TenantVendor: {
      payload: Prisma.$TenantVendorPayload<ExtArgs>
      fields: Prisma.TenantVendorFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenantVendorFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenantVendorFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>
        }
        findFirst: {
          args: Prisma.TenantVendorFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenantVendorFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>
        }
        findMany: {
          args: Prisma.TenantVendorFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>[]
        }
        create: {
          args: Prisma.TenantVendorCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>
        }
        createMany: {
          args: Prisma.TenantVendorCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenantVendorCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>[]
        }
        delete: {
          args: Prisma.TenantVendorDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>
        }
        update: {
          args: Prisma.TenantVendorUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>
        }
        deleteMany: {
          args: Prisma.TenantVendorDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenantVendorUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenantVendorUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>[]
        }
        upsert: {
          args: Prisma.TenantVendorUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantVendorPayload>
        }
        aggregate: {
          args: Prisma.TenantVendorAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenantVendor>
        }
        groupBy: {
          args: Prisma.TenantVendorGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantVendorGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenantVendorCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenantVendorCountAggregateOutputType> | number
        }
      }
    }
    VerificationRequest: {
      payload: Prisma.$VerificationRequestPayload<ExtArgs>
      fields: Prisma.VerificationRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
        }
        findFirst: {
          args: Prisma.VerificationRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
        }
        findMany: {
          args: Prisma.VerificationRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>[]
        }
        create: {
          args: Prisma.VerificationRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
        }
        createMany: {
          args: Prisma.VerificationRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VerificationRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>[]
        }
        delete: {
          args: Prisma.VerificationRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
        }
        update: {
          args: Prisma.VerificationRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
        }
        deleteMany: {
          args: Prisma.VerificationRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VerificationRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>[]
        }
        upsert: {
          args: Prisma.VerificationRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationRequestPayload>
        }
        aggregate: {
          args: Prisma.VerificationRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationRequest>
        }
        groupBy: {
          args: Prisma.VerificationRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationRequestCountAggregateOutputType> | number
        }
      }
    }
    Transactions: {
      payload: Prisma.$TransactionsPayload<ExtArgs>
      fields: Prisma.TransactionsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransactionsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransactionsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>
        }
        findFirst: {
          args: Prisma.TransactionsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransactionsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>
        }
        findMany: {
          args: Prisma.TransactionsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
        }
        create: {
          args: Prisma.TransactionsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>
        }
        createMany: {
          args: Prisma.TransactionsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransactionsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
        }
        delete: {
          args: Prisma.TransactionsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>
        }
        update: {
          args: Prisma.TransactionsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>
        }
        deleteMany: {
          args: Prisma.TransactionsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransactionsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransactionsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
        }
        upsert: {
          args: Prisma.TransactionsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionsPayload>
        }
        aggregate: {
          args: Prisma.TransactionsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransactions>
        }
        groupBy: {
          args: Prisma.TransactionsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionsGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransactionsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionsCountAggregateOutputType> | number
        }
      }
    }
    Payment: {
      payload: Prisma.$PaymentPayload<ExtArgs>
      fields: Prisma.PaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findFirst: {
          args: Prisma.PaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findMany: {
          args: Prisma.PaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        create: {
          args: Prisma.PaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        createMany: {
          args: Prisma.PaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        delete: {
          args: Prisma.PaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        update: {
          args: Prisma.PaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        deleteMany: {
          args: Prisma.PaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        upsert: {
          args: Prisma.PaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        aggregate: {
          args: Prisma.PaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment>
        }
        groupBy: {
          args: Prisma.PaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentCountAggregateOutputType> | number
        }
      }
    }
    Refund: {
      payload: Prisma.$RefundPayload<ExtArgs>
      fields: Prisma.RefundFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefundFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        findFirst: {
          args: Prisma.RefundFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        findMany: {
          args: Prisma.RefundFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        create: {
          args: Prisma.RefundCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        createMany: {
          args: Prisma.RefundCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        delete: {
          args: Prisma.RefundDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        update: {
          args: Prisma.RefundUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        deleteMany: {
          args: Prisma.RefundDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefundUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefundUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>[]
        }
        upsert: {
          args: Prisma.RefundUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefundPayload>
        }
        aggregate: {
          args: Prisma.RefundAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefund>
        }
        groupBy: {
          args: Prisma.RefundGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefundGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefundCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefundCountAggregateOutputType> | number
        }
      }
    }
    Expense: {
      payload: Prisma.$ExpensePayload<ExtArgs>
      fields: Prisma.ExpenseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        findFirst: {
          args: Prisma.ExpenseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        findMany: {
          args: Prisma.ExpenseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        create: {
          args: Prisma.ExpenseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        createMany: {
          args: Prisma.ExpenseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        delete: {
          args: Prisma.ExpenseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        update: {
          args: Prisma.ExpenseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        deleteMany: {
          args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        upsert: {
          args: Prisma.ExpenseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        aggregate: {
          args: Prisma.ExpenseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpense>
        }
        groupBy: {
          args: Prisma.ExpenseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExpenseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    StorefrontUser: {
      payload: Prisma.$StorefrontUserPayload<ExtArgs>
      fields: Prisma.StorefrontUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StorefrontUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StorefrontUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>
        }
        findFirst: {
          args: Prisma.StorefrontUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StorefrontUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>
        }
        findMany: {
          args: Prisma.StorefrontUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>[]
        }
        create: {
          args: Prisma.StorefrontUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>
        }
        createMany: {
          args: Prisma.StorefrontUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StorefrontUserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>[]
        }
        delete: {
          args: Prisma.StorefrontUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>
        }
        update: {
          args: Prisma.StorefrontUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>
        }
        deleteMany: {
          args: Prisma.StorefrontUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StorefrontUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StorefrontUserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>[]
        }
        upsert: {
          args: Prisma.StorefrontUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorefrontUserPayload>
        }
        aggregate: {
          args: Prisma.StorefrontUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStorefrontUser>
        }
        groupBy: {
          args: Prisma.StorefrontUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StorefrontUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.StorefrontUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StorefrontUserCountAggregateOutputType> | number
        }
      }
    }
    AdminUser: {
      payload: Prisma.$AdminUserPayload<ExtArgs>
      fields: Prisma.AdminUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AdminUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>
        }
        findFirst: {
          args: Prisma.AdminUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>
        }
        findMany: {
          args: Prisma.AdminUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
        }
        create: {
          args: Prisma.AdminUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>
        }
        createMany: {
          args: Prisma.AdminUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AdminUserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
        }
        delete: {
          args: Prisma.AdminUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>
        }
        update: {
          args: Prisma.AdminUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>
        }
        deleteMany: {
          args: Prisma.AdminUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AdminUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AdminUserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
        }
        upsert: {
          args: Prisma.AdminUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AdminUserPayload>
        }
        aggregate: {
          args: Prisma.AdminUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAdminUser>
        }
        groupBy: {
          args: Prisma.AdminUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdminUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.AdminUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AdminUserCountAggregateOutputType> | number
        }
      }
    }
    UserRole: {
      payload: Prisma.$UserRolePayload<ExtArgs>
      fields: Prisma.UserRoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        findFirst: {
          args: Prisma.UserRoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        findMany: {
          args: Prisma.UserRoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        create: {
          args: Prisma.UserRoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        createMany: {
          args: Prisma.UserRoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        delete: {
          args: Prisma.UserRoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        update: {
          args: Prisma.UserRoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        deleteMany: {
          args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        upsert: {
          args: Prisma.UserRoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        aggregate: {
          args: Prisma.UserRoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserRole>
        }
        groupBy: {
          args: Prisma.UserRoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserRoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleCountAggregateOutputType> | number
        }
      }
    }
    UserRolePermission: {
      payload: Prisma.$UserRolePermissionPayload<ExtArgs>
      fields: Prisma.UserRolePermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserRolePermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserRolePermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>
        }
        findFirst: {
          args: Prisma.UserRolePermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserRolePermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>
        }
        findMany: {
          args: Prisma.UserRolePermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>[]
        }
        create: {
          args: Prisma.UserRolePermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>
        }
        createMany: {
          args: Prisma.UserRolePermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserRolePermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>[]
        }
        delete: {
          args: Prisma.UserRolePermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>
        }
        update: {
          args: Prisma.UserRolePermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>
        }
        deleteMany: {
          args: Prisma.UserRolePermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserRolePermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserRolePermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>[]
        }
        upsert: {
          args: Prisma.UserRolePermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePermissionPayload>
        }
        aggregate: {
          args: Prisma.UserRolePermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserRolePermission>
        }
        groupBy: {
          args: Prisma.UserRolePermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRolePermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserRolePermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRolePermissionCountAggregateOutputType> | number
        }
      }
    }
    EmailTokens: {
      payload: Prisma.$EmailTokensPayload<ExtArgs>
      fields: Prisma.EmailTokensFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmailTokensFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmailTokensFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>
        }
        findFirst: {
          args: Prisma.EmailTokensFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmailTokensFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>
        }
        findMany: {
          args: Prisma.EmailTokensFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>[]
        }
        create: {
          args: Prisma.EmailTokensCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>
        }
        createMany: {
          args: Prisma.EmailTokensCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmailTokensCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>[]
        }
        delete: {
          args: Prisma.EmailTokensDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>
        }
        update: {
          args: Prisma.EmailTokensUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>
        }
        deleteMany: {
          args: Prisma.EmailTokensDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmailTokensUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmailTokensUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>[]
        }
        upsert: {
          args: Prisma.EmailTokensUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmailTokensPayload>
        }
        aggregate: {
          args: Prisma.EmailTokensAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmailTokens>
        }
        groupBy: {
          args: Prisma.EmailTokensGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailTokensGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmailTokensCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmailTokensCountAggregateOutputType> | number
        }
      }
    }
    Vehicle: {
      payload: Prisma.$VehiclePayload<ExtArgs>
      fields: Prisma.VehicleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>
        }
        findFirst: {
          args: Prisma.VehicleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>
        }
        findMany: {
          args: Prisma.VehicleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>[]
        }
        create: {
          args: Prisma.VehicleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>
        }
        createMany: {
          args: Prisma.VehicleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>[]
        }
        delete: {
          args: Prisma.VehicleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>
        }
        update: {
          args: Prisma.VehicleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>
        }
        deleteMany: {
          args: Prisma.VehicleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>[]
        }
        upsert: {
          args: Prisma.VehicleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePayload>
        }
        aggregate: {
          args: Prisma.VehicleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicle>
        }
        groupBy: {
          args: Prisma.VehicleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleCountAggregateOutputType> | number
        }
      }
    }
    VehicleDiscount: {
      payload: Prisma.$VehicleDiscountPayload<ExtArgs>
      fields: Prisma.VehicleDiscountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleDiscountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleDiscountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>
        }
        findFirst: {
          args: Prisma.VehicleDiscountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleDiscountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>
        }
        findMany: {
          args: Prisma.VehicleDiscountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>[]
        }
        create: {
          args: Prisma.VehicleDiscountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>
        }
        createMany: {
          args: Prisma.VehicleDiscountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleDiscountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>[]
        }
        delete: {
          args: Prisma.VehicleDiscountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>
        }
        update: {
          args: Prisma.VehicleDiscountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>
        }
        deleteMany: {
          args: Prisma.VehicleDiscountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleDiscountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleDiscountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>[]
        }
        upsert: {
          args: Prisma.VehicleDiscountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDiscountPayload>
        }
        aggregate: {
          args: Prisma.VehicleDiscountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleDiscount>
        }
        groupBy: {
          args: Prisma.VehicleDiscountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleDiscountGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleDiscountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleDiscountCountAggregateOutputType> | number
        }
      }
    }
    VehicleDamage: {
      payload: Prisma.$VehicleDamagePayload<ExtArgs>
      fields: Prisma.VehicleDamageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleDamageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleDamageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>
        }
        findFirst: {
          args: Prisma.VehicleDamageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleDamageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>
        }
        findMany: {
          args: Prisma.VehicleDamageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>[]
        }
        create: {
          args: Prisma.VehicleDamageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>
        }
        createMany: {
          args: Prisma.VehicleDamageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleDamageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>[]
        }
        delete: {
          args: Prisma.VehicleDamageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>
        }
        update: {
          args: Prisma.VehicleDamageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>
        }
        deleteMany: {
          args: Prisma.VehicleDamageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleDamageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleDamageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>[]
        }
        upsert: {
          args: Prisma.VehicleDamageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleDamagePayload>
        }
        aggregate: {
          args: Prisma.VehicleDamageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleDamage>
        }
        groupBy: {
          args: Prisma.VehicleDamageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleDamageGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleDamageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleDamageCountAggregateOutputType> | number
        }
      }
    }
    VehiclePart: {
      payload: Prisma.$VehiclePartPayload<ExtArgs>
      fields: Prisma.VehiclePartFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehiclePartFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehiclePartFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>
        }
        findFirst: {
          args: Prisma.VehiclePartFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehiclePartFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>
        }
        findMany: {
          args: Prisma.VehiclePartFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>[]
        }
        create: {
          args: Prisma.VehiclePartCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>
        }
        createMany: {
          args: Prisma.VehiclePartCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehiclePartCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>[]
        }
        delete: {
          args: Prisma.VehiclePartDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>
        }
        update: {
          args: Prisma.VehiclePartUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>
        }
        deleteMany: {
          args: Prisma.VehiclePartDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehiclePartUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehiclePartUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>[]
        }
        upsert: {
          args: Prisma.VehiclePartUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehiclePartPayload>
        }
        aggregate: {
          args: Prisma.VehiclePartAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehiclePart>
        }
        groupBy: {
          args: Prisma.VehiclePartGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehiclePartGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehiclePartCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehiclePartCountAggregateOutputType> | number
        }
      }
    }
    FuelPolicy: {
      payload: Prisma.$FuelPolicyPayload<ExtArgs>
      fields: Prisma.FuelPolicyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FuelPolicyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FuelPolicyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>
        }
        findFirst: {
          args: Prisma.FuelPolicyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FuelPolicyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>
        }
        findMany: {
          args: Prisma.FuelPolicyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>[]
        }
        create: {
          args: Prisma.FuelPolicyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>
        }
        createMany: {
          args: Prisma.FuelPolicyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FuelPolicyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>[]
        }
        delete: {
          args: Prisma.FuelPolicyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>
        }
        update: {
          args: Prisma.FuelPolicyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>
        }
        deleteMany: {
          args: Prisma.FuelPolicyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FuelPolicyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FuelPolicyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>[]
        }
        upsert: {
          args: Prisma.FuelPolicyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuelPolicyPayload>
        }
        aggregate: {
          args: Prisma.FuelPolicyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFuelPolicy>
        }
        groupBy: {
          args: Prisma.FuelPolicyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FuelPolicyGroupByOutputType>[]
        }
        count: {
          args: Prisma.FuelPolicyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FuelPolicyCountAggregateOutputType> | number
        }
      }
    }
    VehicleServiceLog: {
      payload: Prisma.$VehicleServiceLogPayload<ExtArgs>
      fields: Prisma.VehicleServiceLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleServiceLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleServiceLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>
        }
        findFirst: {
          args: Prisma.VehicleServiceLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleServiceLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>
        }
        findMany: {
          args: Prisma.VehicleServiceLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>[]
        }
        create: {
          args: Prisma.VehicleServiceLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>
        }
        createMany: {
          args: Prisma.VehicleServiceLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleServiceLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>[]
        }
        delete: {
          args: Prisma.VehicleServiceLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>
        }
        update: {
          args: Prisma.VehicleServiceLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>
        }
        deleteMany: {
          args: Prisma.VehicleServiceLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleServiceLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleServiceLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>[]
        }
        upsert: {
          args: Prisma.VehicleServiceLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceLogPayload>
        }
        aggregate: {
          args: Prisma.VehicleServiceLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleServiceLog>
        }
        groupBy: {
          args: Prisma.VehicleServiceLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleServiceLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleServiceLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleServiceLogCountAggregateOutputType> | number
        }
      }
    }
    VehicleMaintenance: {
      payload: Prisma.$VehicleMaintenancePayload<ExtArgs>
      fields: Prisma.VehicleMaintenanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleMaintenanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleMaintenanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>
        }
        findFirst: {
          args: Prisma.VehicleMaintenanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleMaintenanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>
        }
        findMany: {
          args: Prisma.VehicleMaintenanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>[]
        }
        create: {
          args: Prisma.VehicleMaintenanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>
        }
        createMany: {
          args: Prisma.VehicleMaintenanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleMaintenanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>[]
        }
        delete: {
          args: Prisma.VehicleMaintenanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>
        }
        update: {
          args: Prisma.VehicleMaintenanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>
        }
        deleteMany: {
          args: Prisma.VehicleMaintenanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleMaintenanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleMaintenanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>[]
        }
        upsert: {
          args: Prisma.VehicleMaintenanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleMaintenancePayload>
        }
        aggregate: {
          args: Prisma.VehicleMaintenanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleMaintenance>
        }
        groupBy: {
          args: Prisma.VehicleMaintenanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleMaintenanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleMaintenanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleMaintenanceCountAggregateOutputType> | number
        }
      }
    }
    VehicleServiceSchedule: {
      payload: Prisma.$VehicleServiceSchedulePayload<ExtArgs>
      fields: Prisma.VehicleServiceScheduleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleServiceScheduleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleServiceScheduleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>
        }
        findFirst: {
          args: Prisma.VehicleServiceScheduleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleServiceScheduleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>
        }
        findMany: {
          args: Prisma.VehicleServiceScheduleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>[]
        }
        create: {
          args: Prisma.VehicleServiceScheduleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>
        }
        createMany: {
          args: Prisma.VehicleServiceScheduleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleServiceScheduleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>[]
        }
        delete: {
          args: Prisma.VehicleServiceScheduleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>
        }
        update: {
          args: Prisma.VehicleServiceScheduleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>
        }
        deleteMany: {
          args: Prisma.VehicleServiceScheduleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleServiceScheduleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleServiceScheduleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>[]
        }
        upsert: {
          args: Prisma.VehicleServiceScheduleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleServiceSchedulePayload>
        }
        aggregate: {
          args: Prisma.VehicleServiceScheduleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleServiceSchedule>
        }
        groupBy: {
          args: Prisma.VehicleServiceScheduleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleServiceScheduleGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleServiceScheduleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleServiceScheduleCountAggregateOutputType> | number
        }
      }
    }
    BookingVehicleHistory: {
      payload: Prisma.$BookingVehicleHistoryPayload<ExtArgs>
      fields: Prisma.BookingVehicleHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BookingVehicleHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BookingVehicleHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>
        }
        findFirst: {
          args: Prisma.BookingVehicleHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BookingVehicleHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>
        }
        findMany: {
          args: Prisma.BookingVehicleHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>[]
        }
        create: {
          args: Prisma.BookingVehicleHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>
        }
        createMany: {
          args: Prisma.BookingVehicleHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BookingVehicleHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>[]
        }
        delete: {
          args: Prisma.BookingVehicleHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>
        }
        update: {
          args: Prisma.BookingVehicleHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>
        }
        deleteMany: {
          args: Prisma.BookingVehicleHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BookingVehicleHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BookingVehicleHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>[]
        }
        upsert: {
          args: Prisma.BookingVehicleHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BookingVehicleHistoryPayload>
        }
        aggregate: {
          args: Prisma.BookingVehicleHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBookingVehicleHistory>
        }
        groupBy: {
          args: Prisma.BookingVehicleHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BookingVehicleHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.BookingVehicleHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BookingVehicleHistoryCountAggregateOutputType> | number
        }
      }
    }
    VehicleEvent: {
      payload: Prisma.$VehicleEventPayload<ExtArgs>
      fields: Prisma.VehicleEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VehicleEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VehicleEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>
        }
        findFirst: {
          args: Prisma.VehicleEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VehicleEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>
        }
        findMany: {
          args: Prisma.VehicleEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>[]
        }
        create: {
          args: Prisma.VehicleEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>
        }
        createMany: {
          args: Prisma.VehicleEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VehicleEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>[]
        }
        delete: {
          args: Prisma.VehicleEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>
        }
        update: {
          args: Prisma.VehicleEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>
        }
        deleteMany: {
          args: Prisma.VehicleEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VehicleEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VehicleEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>[]
        }
        upsert: {
          args: Prisma.VehicleEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VehicleEventPayload>
        }
        aggregate: {
          args: Prisma.VehicleEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVehicleEvent>
        }
        groupBy: {
          args: Prisma.VehicleEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.VehicleEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VehicleEventCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const ServiceScalarFieldEnum = {
  id: 'id',
  service: 'service',
  description: 'description',
  icon: 'icon'
} as const

export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


export const ChargeTypeScalarFieldEnum = {
  id: 'id',
  chargeType: 'chargeType',
  unit: 'unit'
} as const

export type ChargeTypeScalarFieldEnum = (typeof ChargeTypeScalarFieldEnum)[keyof typeof ChargeTypeScalarFieldEnum]


export const VehicleBrandScalarFieldEnum = {
  id: 'id',
  brand: 'brand'
} as const

export type VehicleBrandScalarFieldEnum = (typeof VehicleBrandScalarFieldEnum)[keyof typeof VehicleBrandScalarFieldEnum]


export const VehicleModelScalarFieldEnum = {
  id: 'id',
  model: 'model',
  brandId: 'brandId',
  typeId: 'typeId'
} as const

export type VehicleModelScalarFieldEnum = (typeof VehicleModelScalarFieldEnum)[keyof typeof VehicleModelScalarFieldEnum]


export const VehicleBodyTypeScalarFieldEnum = {
  id: 'id',
  bodyType: 'bodyType'
} as const

export type VehicleBodyTypeScalarFieldEnum = (typeof VehicleBodyTypeScalarFieldEnum)[keyof typeof VehicleBodyTypeScalarFieldEnum]


export const VehicleStatusScalarFieldEnum = {
  id: 'id',
  status: 'status'
} as const

export type VehicleStatusScalarFieldEnum = (typeof VehicleStatusScalarFieldEnum)[keyof typeof VehicleStatusScalarFieldEnum]


export const FuelTypeScalarFieldEnum = {
  id: 'id',
  fuel: 'fuel'
} as const

export type FuelTypeScalarFieldEnum = (typeof FuelTypeScalarFieldEnum)[keyof typeof FuelTypeScalarFieldEnum]


export const TransmissionScalarFieldEnum = {
  id: 'id',
  transmission: 'transmission',
  transmissionCode: 'transmissionCode'
} as const

export type TransmissionScalarFieldEnum = (typeof TransmissionScalarFieldEnum)[keyof typeof TransmissionScalarFieldEnum]


export const VehicleFeatureScalarFieldEnum = {
  id: 'id',
  feature: 'feature'
} as const

export type VehicleFeatureScalarFieldEnum = (typeof VehicleFeatureScalarFieldEnum)[keyof typeof VehicleFeatureScalarFieldEnum]


export const WheelDriveScalarFieldEnum = {
  id: 'id',
  drive: 'drive',
  code: 'code'
} as const

export type WheelDriveScalarFieldEnum = (typeof WheelDriveScalarFieldEnum)[keyof typeof WheelDriveScalarFieldEnum]


export const InvoiceSequenceScalarFieldEnum = {
  id: 'id',
  prefix: 'prefix',
  example: 'example'
} as const

export type InvoiceSequenceScalarFieldEnum = (typeof InvoiceSequenceScalarFieldEnum)[keyof typeof InvoiceSequenceScalarFieldEnum]


export const CountryScalarFieldEnum = {
  id: 'id',
  code: 'code',
  iso3: 'iso3',
  phoneCode: 'phoneCode',
  currency: 'currency',
  cscId: 'cscId',
  country: 'country',
  createdAt: 'createdAt',
  updatedBy: 'updatedBy'
} as const

export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


export const StateScalarFieldEnum = {
  id: 'id',
  countryId: 'countryId',
  state: 'state',
  cscId: 'cscId',
  iso2: 'iso2',
  type: 'type'
} as const

export type StateScalarFieldEnum = (typeof StateScalarFieldEnum)[keyof typeof StateScalarFieldEnum]


export const VillageScalarFieldEnum = {
  id: 'id',
  stateId: 'stateId',
  village: 'village',
  cscId: 'cscId'
} as const

export type VillageScalarFieldEnum = (typeof VillageScalarFieldEnum)[keyof typeof VillageScalarFieldEnum]


export const MaintenanceServiceScalarFieldEnum = {
  id: 'id',
  service: 'service',
  description: 'description'
} as const

export type MaintenanceServiceScalarFieldEnum = (typeof MaintenanceServiceScalarFieldEnum)[keyof typeof MaintenanceServiceScalarFieldEnum]


export const DocumentTypeScalarFieldEnum = {
  id: 'id',
  type: 'type'
} as const

export type DocumentTypeScalarFieldEnum = (typeof DocumentTypeScalarFieldEnum)[keyof typeof DocumentTypeScalarFieldEnum]


export const PresetLocationScalarFieldEnum = {
  id: 'id',
  location: 'location',
  street: 'street',
  villageId: 'villageId',
  stateId: 'stateId',
  countryId: 'countryId'
} as const

export type PresetLocationScalarFieldEnum = (typeof PresetLocationScalarFieldEnum)[keyof typeof PresetLocationScalarFieldEnum]


export const LicenseClassScalarFieldEnum = {
  id: 'id',
  class: 'class',
  name: 'name',
  description: 'description',
  countryId: 'countryId'
} as const

export type LicenseClassScalarFieldEnum = (typeof LicenseClassScalarFieldEnum)[keyof typeof LicenseClassScalarFieldEnum]


export const MessengerAppScalarFieldEnum = {
  id: 'id',
  app: 'app',
  icon: 'icon'
} as const

export type MessengerAppScalarFieldEnum = (typeof MessengerAppScalarFieldEnum)[keyof typeof MessengerAppScalarFieldEnum]


export const EquipmentScalarFieldEnum = {
  id: 'id',
  equipment: 'equipment',
  description: 'description',
  icon: 'icon'
} as const

export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


export const ContactTypeScalarFieldEnum = {
  id: 'id',
  type: 'type'
} as const

export type ContactTypeScalarFieldEnum = (typeof ContactTypeScalarFieldEnum)[keyof typeof ContactTypeScalarFieldEnum]


export const PaymentTypeScalarFieldEnum = {
  id: 'id',
  type: 'type',
  description: 'description'
} as const

export type PaymentTypeScalarFieldEnum = (typeof PaymentTypeScalarFieldEnum)[keyof typeof PaymentTypeScalarFieldEnum]


export const VendorTypeScalarFieldEnum = {
  id: 'id',
  type: 'type'
} as const

export type VendorTypeScalarFieldEnum = (typeof VendorTypeScalarFieldEnum)[keyof typeof VendorTypeScalarFieldEnum]


export const PortScalarFieldEnum = {
  id: 'id',
  port: 'port',
  type: 'type',
  countryId: 'countryId'
} as const

export type PortScalarFieldEnum = (typeof PortScalarFieldEnum)[keyof typeof PortScalarFieldEnum]


export const CustomerScalarFieldEnum = {
  id: 'id',
  firstName: 'firstName',
  lastName: 'lastName',
  gender: 'gender',
  dateOfBirth: 'dateOfBirth',
  email: 'email',
  phone: 'phone',
  tenantId: 'tenantId',
  profileImage: 'profileImage',
  status: 'status',
  experience: 'experience',
  isActive: 'isActive',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy',
  storefrontId: 'storefrontId'
} as const

export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


export const CustomerMessengerAppScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  appId: 'appId',
  account: 'account',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomerMessengerAppScalarFieldEnum = (typeof CustomerMessengerAppScalarFieldEnum)[keyof typeof CustomerMessengerAppScalarFieldEnum]


export const CustomerAddressScalarFieldEnum = {
  id: 'id',
  street: 'street',
  countryId: 'countryId',
  customerId: 'customerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  stateId: 'stateId',
  villageId: 'villageId'
} as const

export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


export const CustomerDocumentScalarFieldEnum = {
  id: 'id',
  documentId: 'documentId',
  customerId: 'customerId',
  documentNumber: 'documentNumber',
  issuedDate: 'issuedDate',
  expiryDate: 'expiryDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  documents: 'documents',
  notes: 'notes'
} as const

export type CustomerDocumentScalarFieldEnum = (typeof CustomerDocumentScalarFieldEnum)[keyof typeof CustomerDocumentScalarFieldEnum]


export const DriverLicenseScalarFieldEnum = {
  id: 'id',
  classId: 'classId',
  countryId: 'countryId',
  customerId: 'customerId',
  licenseNumber: 'licenseNumber',
  licenseExpiry: 'licenseExpiry',
  licenseIssued: 'licenseIssued',
  image: 'image'
} as const

export type DriverLicenseScalarFieldEnum = (typeof DriverLicenseScalarFieldEnum)[keyof typeof DriverLicenseScalarFieldEnum]


export const CustomerViolationScalarFieldEnum = {
  id: 'id',
  violationId: 'violationId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  customerId: 'customerId',
  tenantId: 'tenantId',
  notes: 'notes',
  violationDate: 'violationDate',
  deletedAt: 'deletedAt',
  isDeleted: 'isDeleted'
} as const

export type CustomerViolationScalarFieldEnum = (typeof CustomerViolationScalarFieldEnum)[keyof typeof CustomerViolationScalarFieldEnum]


export const RentalAgreementScalarFieldEnum = {
  id: 'id',
  number: 'number',
  rentalId: 'rentalId',
  tenantId: 'tenantId',
  customerId: 'customerId',
  agreementUrl: 'agreementUrl',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  signableUrl: 'signableUrl'
} as const

export type RentalAgreementScalarFieldEnum = (typeof RentalAgreementScalarFieldEnum)[keyof typeof RentalAgreementScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  invoiceNumber: 'invoiceNumber',
  amount: 'amount',
  rentalId: 'rentalId',
  tenantId: 'tenantId',
  customerId: 'customerId',
  status: 'status',
  invoiceUrl: 'invoiceUrl',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const PaymentReceiptScalarFieldEnum = {
  id: 'id',
  receiptNumber: 'receiptNumber',
  paymentId: 'paymentId',
  amount: 'amount',
  bookingId: 'bookingId',
  tenantId: 'tenantId',
  customerId: 'customerId',
  receiptUrl: 'receiptUrl',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy'
} as const

export type PaymentReceiptScalarFieldEnum = (typeof PaymentReceiptScalarFieldEnum)[keyof typeof PaymentReceiptScalarFieldEnum]


export const CaribbeanCountryScalarFieldEnum = {
  id: 'id',
  countryId: 'countryId',
  image: 'image',
  isActive: 'isActive',
  description: 'description'
} as const

export type CaribbeanCountryScalarFieldEnum = (typeof CaribbeanCountryScalarFieldEnum)[keyof typeof CaribbeanCountryScalarFieldEnum]


export const ShopDMMerchantScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  merchant_handle: 'merchant_handle',
  merchant_secret: 'merchant_secret'
} as const

export type ShopDMMerchantScalarFieldEnum = (typeof ShopDMMerchantScalarFieldEnum)[keyof typeof ShopDMMerchantScalarFieldEnum]


export const CurrencyScalarFieldEnum = {
  id: 'id',
  code: 'code',
  currency: 'currency',
  symbol: 'symbol'
} as const

export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


export const TenantCurrencyRateScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  currencyId: 'currencyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  enabled: 'enabled',
  fromRate: 'fromRate',
  toRate: 'toRate'
} as const

export type TenantCurrencyRateScalarFieldEnum = (typeof TenantCurrencyRateScalarFieldEnum)[keyof typeof TenantCurrencyRateScalarFieldEnum]


export const ExchangeRateScalarFieldEnum = {
  id: 'id',
  base: 'base',
  target: 'target',
  rate: 'rate',
  updatedAt: 'updatedAt',
  createdAt: 'createdAt'
} as const

export type ExchangeRateScalarFieldEnum = (typeof ExchangeRateScalarFieldEnum)[keyof typeof ExchangeRateScalarFieldEnum]


export const FormScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  type: 'type',
  expiresAt: 'expiresAt',
  submitted: 'submitted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


export const FormResponseScalarFieldEnum = {
  id: 'id',
  formId: 'formId',
  data: 'data',
  submittedAt: 'submittedAt'
} as const

export type FormResponseScalarFieldEnum = (typeof FormResponseScalarFieldEnum)[keyof typeof FormResponseScalarFieldEnum]


export const RentalActivityScalarFieldEnum = {
  id: 'id',
  customerId: 'customerId',
  rentalId: 'rentalId',
  action: 'action',
  vehicleId: 'vehicleId',
  createdAt: 'createdAt',
  createdBy: 'createdBy',
  tenantId: 'tenantId'
} as const

export type RentalActivityScalarFieldEnum = (typeof RentalActivityScalarFieldEnum)[keyof typeof RentalActivityScalarFieldEnum]


export const TenantNotificationScalarFieldEnum = {
  id: 'id',
  title: 'title',
  type: 'type',
  priority: 'priority',
  message: 'message',
  tenantId: 'tenantId',
  actionUrl: 'actionUrl',
  createdAt: 'createdAt',
  isDeleted: 'isDeleted'
} as const

export type TenantNotificationScalarFieldEnum = (typeof TenantNotificationScalarFieldEnum)[keyof typeof TenantNotificationScalarFieldEnum]


export const NotificationReadStatusScalarFieldEnum = {
  id: 'id',
  notificationId: 'notificationId',
  userId: 'userId',
  readAt: 'readAt'
} as const

export type NotificationReadStatusScalarFieldEnum = (typeof NotificationReadStatusScalarFieldEnum)[keyof typeof NotificationReadStatusScalarFieldEnum]


export const AppPermissionScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  categoryId: 'categoryId'
} as const

export type AppPermissionScalarFieldEnum = (typeof AppPermissionScalarFieldEnum)[keyof typeof AppPermissionScalarFieldEnum]


export const PermissionCategoryScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PermissionCategoryScalarFieldEnum = (typeof PermissionCategoryScalarFieldEnum)[keyof typeof PermissionCategoryScalarFieldEnum]


export const RentalScalarFieldEnum = {
  id: 'id',
  rentalNumber: 'rentalNumber',
  startDate: 'startDate',
  endDate: 'endDate',
  pickupLocationId: 'pickupLocationId',
  returnLocationId: 'returnLocationId',
  vehicleId: 'vehicleId',
  originalVehicleId: 'originalVehicleId',
  vehicleSwapped: 'vehicleSwapped',
  agent: 'agent',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  tenantId: 'tenantId',
  status: 'status',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  notes: 'notes',
  isDeleted: 'isDeleted',
  chargeTypeId: 'chargeTypeId',
  bookingCode: 'bookingCode',
  deletedAt: 'deletedAt'
} as const

export type RentalScalarFieldEnum = (typeof RentalScalarFieldEnum)[keyof typeof RentalScalarFieldEnum]


export const StorefrontBookingScalarFieldEnum = {
  id: 'id',
  rentalId: 'rentalId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StorefrontBookingScalarFieldEnum = (typeof StorefrontBookingScalarFieldEnum)[keyof typeof StorefrontBookingScalarFieldEnum]


export const RentalDriverScalarFieldEnum = {
  id: 'id',
  rentalId: 'rentalId',
  driverId: 'driverId',
  isPrimary: 'isPrimary'
} as const

export type RentalDriverScalarFieldEnum = (typeof RentalDriverScalarFieldEnum)[keyof typeof RentalDriverScalarFieldEnum]


export const ValuesScalarFieldEnum = {
  id: 'id',
  numberOfDays: 'numberOfDays',
  basePrice: 'basePrice',
  totalCost: 'totalCost',
  discount: 'discount',
  deliveryFee: 'deliveryFee',
  collectionFee: 'collectionFee',
  deposit: 'deposit',
  totalExtras: 'totalExtras',
  subTotal: 'subTotal',
  netTotal: 'netTotal',
  amountDue: 'amountDue',
  rentalId: 'rentalId',
  discountAmount: 'discountAmount',
  discountPolicy: 'discountPolicy',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  additionalDriverFees: 'additionalDriverFees',
  cancellationFee: 'cancellationFee',
  lateFee: 'lateFee',
  customBasePrice: 'customBasePrice',
  customCollectionFee: 'customCollectionFee',
  customDeliveryFee: 'customDeliveryFee',
  customDeposit: 'customDeposit',
  customDiscount: 'customDiscount',
  customTotalCost: 'customTotalCost'
} as const

export type ValuesScalarFieldEnum = (typeof ValuesScalarFieldEnum)[keyof typeof ValuesScalarFieldEnum]


export const RentalExtraScalarFieldEnum = {
  id: 'id',
  extraId: 'extraId',
  amount: 'amount',
  valuesId: 'valuesId',
  customAmount: 'customAmount'
} as const

export type RentalExtraScalarFieldEnum = (typeof RentalExtraScalarFieldEnum)[keyof typeof RentalExtraScalarFieldEnum]


export const RentalChargeScalarFieldEnum = {
  id: 'id',
  rentalId: 'rentalId',
  charge: 'charge',
  reason: 'reason',
  amount: 'amount',
  customerId: 'customerId',
  tenantId: 'tenantId',
  createdAt: 'createdAt'
} as const

export type RentalChargeScalarFieldEnum = (typeof RentalChargeScalarFieldEnum)[keyof typeof RentalChargeScalarFieldEnum]


export const VesselInfoScalarFieldEnum = {
  id: 'id',
  bookingId: 'bookingId',
  portId: 'portId',
  direction: 'direction',
  type: 'type',
  carrier: 'carrier',
  number: 'number',
  arrival: 'arrival',
  departure: 'departure',
  notes: 'notes'
} as const

export type VesselInfoScalarFieldEnum = (typeof VesselInfoScalarFieldEnum)[keyof typeof VesselInfoScalarFieldEnum]


export const TenantWeeklyStatsScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  week: 'week',
  year: 'year',
  stat: 'stat',
  value: 'value',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantWeeklyStatsScalarFieldEnum = (typeof TenantWeeklyStatsScalarFieldEnum)[keyof typeof TenantWeeklyStatsScalarFieldEnum]


export const TenantYearlyStatsScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  year: 'year',
  stat: 'stat',
  value: 'value',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantYearlyStatsScalarFieldEnum = (typeof TenantYearlyStatsScalarFieldEnum)[keyof typeof TenantYearlyStatsScalarFieldEnum]


export const TenantMonthlyStatsScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  month: 'month',
  year: 'year',
  stat: 'stat',
  value: 'value',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantMonthlyStatsScalarFieldEnum = (typeof TenantMonthlyStatsScalarFieldEnum)[keyof typeof TenantMonthlyStatsScalarFieldEnum]


export const TenantMonthlyRentalStatsScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  month: 'month',
  year: 'year',
  stat: 'stat',
  status: 'status',
  value: 'value',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantMonthlyRentalStatsScalarFieldEnum = (typeof TenantMonthlyRentalStatsScalarFieldEnum)[keyof typeof TenantMonthlyRentalStatsScalarFieldEnum]


export const TenantRatingsScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  rating: 'rating',
  comment: 'comment',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  email: 'email',
  fullName: 'fullName'
} as const

export type TenantRatingsScalarFieldEnum = (typeof TenantRatingsScalarFieldEnum)[keyof typeof TenantRatingsScalarFieldEnum]


export const SiteRatingsScalarFieldEnum = {
  id: 'id',
  fullName: 'fullName',
  email: 'email',
  rating: 'rating',
  comment: 'comment',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SiteRatingsScalarFieldEnum = (typeof SiteRatingsScalarFieldEnum)[keyof typeof SiteRatingsScalarFieldEnum]


export const SubscriptionPlanScalarFieldEnum = {
  id: 'id',
  description: 'description',
  name: 'name',
  planCode: 'planCode',
  planId: 'planId',
  period: 'period',
  price: 'price'
} as const

export type SubscriptionPlanScalarFieldEnum = (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum]


export const PlanFeaturesScalarFieldEnum = {
  id: 'id',
  planId: 'planId',
  feature: 'feature'
} as const

export type PlanFeaturesScalarFieldEnum = (typeof PlanFeaturesScalarFieldEnum)[keyof typeof PlanFeaturesScalarFieldEnum]


export const PlanDetailsScalarFieldEnum = {
  id: 'id',
  planId: 'planId',
  users: 'users',
  vehicles: 'vehicles'
} as const

export type PlanDetailsScalarFieldEnum = (typeof PlanDetailsScalarFieldEnum)[keyof typeof PlanDetailsScalarFieldEnum]


export const TenantScalarFieldEnum = {
  id: 'id',
  tenantCode: 'tenantCode',
  tenantName: 'tenantName',
  email: 'email',
  number: 'number',
  whatsappNumber: 'whatsappNumber',
  whatsappNotifications: 'whatsappNotifications',
  emailNotifications: 'emailNotifications',
  currencyId: 'currencyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  logo: 'logo',
  setupCompleted: 'setupCompleted',
  financialYearStart: 'financialYearStart',
  invoiceSequenceId: 'invoiceSequenceId',
  invoiceFootNotes: 'invoiceFootNotes',
  storefrontEnabled: 'storefrontEnabled',
  subscriptionId: 'subscriptionId',
  securityDeposit: 'securityDeposit',
  rating: 'rating',
  description: 'description',
  cancellationPolicyId: 'cancellationPolicyId',
  latePolicyId: 'latePolicyId',
  additionalDriverFee: 'additionalDriverFee',
  daysInMonth: 'daysInMonth',
  slug: 'slug',
  subdomain: 'subdomain',
  merchantId: 'merchantId',
  businessVerified: 'businessVerified',
  emailVerified: 'emailVerified',
  isDeleted: 'isDeleted',
  endTime: 'endTime',
  startTime: 'startTime',
  firmaWorkspaceId: 'firmaWorkspaceId',
  firmaApiKey: 'firmaApiKey',
  firmaApiKeyAt: 'firmaApiKeyAt'
} as const

export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


export const EmailVerificationScalarFieldEnum = {
  id: 'id',
  email: 'email',
  token: 'token',
  createdAt: 'createdAt',
  expiresAt: 'expiresAt',
  verified: 'verified',
  tenantId: 'tenantId'
} as const

export type EmailVerificationScalarFieldEnum = (typeof EmailVerificationScalarFieldEnum)[keyof typeof EmailVerificationScalarFieldEnum]


export const PaymentMethodScalarFieldEnum = {
  id: 'id',
  method: 'method',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentMethodScalarFieldEnum = (typeof PaymentMethodScalarFieldEnum)[keyof typeof PaymentMethodScalarFieldEnum]


export const AddressScalarFieldEnum = {
  id: 'id',
  street: 'street',
  countryId: 'countryId',
  tenantId: 'tenantId',
  stateId: 'stateId',
  villageId: 'villageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


export const TenantLocationScalarFieldEnum = {
  id: 'id',
  location: 'location',
  pickupEnabled: 'pickupEnabled',
  returnEnabled: 'returnEnabled',
  deliveryFee: 'deliveryFee',
  collectionFee: 'collectionFee',
  tenantId: 'tenantId',
  minimumRentalPeriod: 'minimumRentalPeriod',
  isDeleted: 'isDeleted',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy',
  storefrontEnabled: 'storefrontEnabled',
  createdAt: 'createdAt'
} as const

export type TenantLocationScalarFieldEnum = (typeof TenantLocationScalarFieldEnum)[keyof typeof TenantLocationScalarFieldEnum]


export const TenantInsuranceScalarFieldEnum = {
  id: 'id',
  insurance: 'insurance',
  description: 'description',
  pricePolicy: 'pricePolicy',
  price: 'price',
  tenantId: 'tenantId',
  isActive: 'isActive',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy'
} as const

export type TenantInsuranceScalarFieldEnum = (typeof TenantInsuranceScalarFieldEnum)[keyof typeof TenantInsuranceScalarFieldEnum]


export const TenantEquipmentScalarFieldEnum = {
  id: 'id',
  equipmentId: 'equipmentId',
  pricePolicy: 'pricePolicy',
  price: 'price',
  tenantId: 'tenantId',
  isActive: 'isActive',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy'
} as const

export type TenantEquipmentScalarFieldEnum = (typeof TenantEquipmentScalarFieldEnum)[keyof typeof TenantEquipmentScalarFieldEnum]


export const TenantServiceScalarFieldEnum = {
  id: 'id',
  serviceId: 'serviceId',
  tenantId: 'tenantId',
  price: 'price',
  pricePolicy: 'pricePolicy',
  isActive: 'isActive',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy'
} as const

export type TenantServiceScalarFieldEnum = (typeof TenantServiceScalarFieldEnum)[keyof typeof TenantServiceScalarFieldEnum]


export const TenantSubscriptionScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  planId: 'planId'
} as const

export type TenantSubscriptionScalarFieldEnum = (typeof TenantSubscriptionScalarFieldEnum)[keyof typeof TenantSubscriptionScalarFieldEnum]


export const TenantContactScalarFieldEnum = {
  id: 'id',
  name: 'name',
  email: 'email',
  phone: 'phone',
  tenantId: 'tenantId',
  contactTypeId: 'contactTypeId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TenantContactScalarFieldEnum = (typeof TenantContactScalarFieldEnum)[keyof typeof TenantContactScalarFieldEnum]


export const TenantRemindersScalarFieldEnum = {
  id: 'id',
  reminder: 'reminder',
  date: 'date',
  tenantId: 'tenantId',
  completed: 'completed',
  completedAt: 'completedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy'
} as const

export type TenantRemindersScalarFieldEnum = (typeof TenantRemindersScalarFieldEnum)[keyof typeof TenantRemindersScalarFieldEnum]


export const CancellationPolicyScalarFieldEnum = {
  id: 'id',
  minimumDays: 'minimumDays',
  policy: 'policy',
  amount: 'amount',
  tenantId: 'tenantId',
  updatedBy: 'updatedBy',
  bookingMinimumDays: 'bookingMinimumDays'
} as const

export type CancellationPolicyScalarFieldEnum = (typeof CancellationPolicyScalarFieldEnum)[keyof typeof CancellationPolicyScalarFieldEnum]


export const LatePolicyScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  maxHours: 'maxHours',
  updatedBy: 'updatedBy',
  tenantId: 'tenantId'
} as const

export type LatePolicyScalarFieldEnum = (typeof LatePolicyScalarFieldEnum)[keyof typeof LatePolicyScalarFieldEnum]


export const TenantViolationScalarFieldEnum = {
  id: 'id',
  violation: 'violation',
  tenantId: 'tenantId',
  description: 'description',
  amount: 'amount',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isDeleted: 'isDeleted',
  deletedAt: 'deletedAt'
} as const

export type TenantViolationScalarFieldEnum = (typeof TenantViolationScalarFieldEnum)[keyof typeof TenantViolationScalarFieldEnum]


export const TenantVendorScalarFieldEnum = {
  id: 'id',
  vendor: 'vendor',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy',
  deletedAt: 'deletedAt',
  contactName: 'contactName',
  isDeleted: 'isDeleted',
  phone: 'phone',
  email: 'email'
} as const

export type TenantVendorScalarFieldEnum = (typeof TenantVendorScalarFieldEnum)[keyof typeof TenantVendorScalarFieldEnum]


export const VerificationRequestScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  documentType: 'documentType',
  documentUrl: 'documentUrl',
  idType: 'idType',
  idUrl: 'idUrl',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  reviewedAt: 'reviewedAt',
  reviewedBy: 'reviewedBy'
} as const

export type VerificationRequestScalarFieldEnum = (typeof VerificationRequestScalarFieldEnum)[keyof typeof VerificationRequestScalarFieldEnum]


export const TransactionsScalarFieldEnum = {
  id: 'id',
  number: 'number',
  amount: 'amount',
  type: 'type',
  isDeleted: 'isDeleted',
  transactionDate: 'transactionDate',
  createdAt: 'createdAt',
  createdBy: 'createdBy',
  paymentId: 'paymentId',
  tenantId: 'tenantId',
  rentalId: 'rentalId',
  details: 'details',
  refundId: 'refundId',
  expenseId: 'expenseId',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy'
} as const

export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


export const PaymentScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  paymentMethodId: 'paymentMethodId',
  paymentTypeId: 'paymentTypeId',
  tenantId: 'tenantId',
  rentalId: 'rentalId',
  notes: 'notes',
  isDeleted: 'isDeleted',
  paymentDate: 'paymentDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy',
  customerId: 'customerId',
  currencyId: 'currencyId',
  payer: 'payer',
  payment: 'payment'
} as const

export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


export const RefundScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  tenantId: 'tenantId',
  rentalId: 'rentalId',
  reason: 'reason',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  refundDate: 'refundDate',
  createdBy: 'createdBy',
  customerId: 'customerId',
  payee: 'payee',
  refund: 'refund',
  payment: 'payment',
  updatedBy: 'updatedBy'
} as const

export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


export const ExpenseScalarFieldEnum = {
  id: 'id',
  tenantId: 'tenantId',
  vehicleId: 'vehicleId',
  vendorId: 'vendorId',
  amount: 'amount',
  expenseDate: 'expenseDate',
  notes: 'notes',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  maintenanceId: 'maintenanceId',
  expense: 'expense',
  payee: 'payee'
} as const

export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  password: 'password',
  firstName: 'firstName',
  lastName: 'lastName',
  username: 'username',
  tenantId: 'tenantId',
  roleId: 'roleId',
  lastChanged: 'lastChanged',
  email: 'email',
  profilePicture: 'profilePicture',
  show: 'show',
  deletedAt: 'deletedAt',
  isDeleted: 'isDeleted',
  requirePasswordChange: 'requirePasswordChange',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const StorefrontUserScalarFieldEnum = {
  id: 'id',
  password: 'password',
  firstName: 'firstName',
  lastName: 'lastName',
  dateOfBirth: 'dateOfBirth',
  gender: 'gender',
  email: 'email',
  phone: 'phone',
  driverLicenseNumber: 'driverLicenseNumber',
  licenseExpiry: 'licenseExpiry',
  street: 'street',
  villageId: 'villageId',
  stateId: 'stateId',
  countryId: 'countryId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  profilePicture: 'profilePicture',
  licenseIssued: 'licenseIssued',
  license: 'license',
  deletedAt: 'deletedAt',
  isDeleted: 'isDeleted'
} as const

export type StorefrontUserScalarFieldEnum = (typeof StorefrontUserScalarFieldEnum)[keyof typeof StorefrontUserScalarFieldEnum]


export const AdminUserScalarFieldEnum = {
  id: 'id',
  password: 'password',
  firstName: 'firstName',
  lastName: 'lastName',
  email: 'email',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  username: 'username'
} as const

export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


export const UserRoleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  tenantId: 'tenantId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  isDeleted: 'isDeleted',
  updatedBy: 'updatedBy',
  show: 'show'
} as const

export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


export const UserRolePermissionScalarFieldEnum = {
  id: 'id',
  roleId: 'roleId',
  permissionId: 'permissionId',
  assignedBy: 'assignedBy',
  assignedAt: 'assignedAt'
} as const

export type UserRolePermissionScalarFieldEnum = (typeof UserRolePermissionScalarFieldEnum)[keyof typeof UserRolePermissionScalarFieldEnum]


export const EmailTokensScalarFieldEnum = {
  id: 'id',
  email: 'email',
  token: 'token',
  createdAt: 'createdAt',
  expiresAt: 'expiresAt',
  verified: 'verified',
  expired: 'expired'
} as const

export type EmailTokensScalarFieldEnum = (typeof EmailTokensScalarFieldEnum)[keyof typeof EmailTokensScalarFieldEnum]


export const VehicleScalarFieldEnum = {
  id: 'id',
  year: 'year',
  color: 'color',
  licensePlate: 'licensePlate',
  engineVolume: 'engineVolume',
  vehicleStatusId: 'vehicleStatusId',
  fuelTypeId: 'fuelTypeId',
  transmissionId: 'transmissionId',
  wheelDriveId: 'wheelDriveId',
  fuelLevel: 'fuelLevel',
  odometer: 'odometer',
  steering: 'steering',
  featuredImage: 'featuredImage',
  images: 'images',
  numberOfSeats: 'numberOfSeats',
  numberOfDoors: 'numberOfDoors',
  vin: 'vin',
  brandId: 'brandId',
  modelId: 'modelId',
  tenantId: 'tenantId',
  locationId: 'locationId',
  isActive: 'isActive',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  drivingExperience: 'drivingExperience',
  fuelPolicyId: 'fuelPolicyId',
  minimumAge: 'minimumAge',
  minimumRental: 'minimumRental',
  refundAmount: 'refundAmount',
  timeBetweenRentals: 'timeBetweenRentals',
  dayPrice: 'dayPrice',
  monthPrice: 'monthPrice',
  weekPrice: 'weekPrice',
  storefrontEnabled: 'storefrontEnabled'
} as const

export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


export const VehicleDiscountScalarFieldEnum = {
  id: 'id',
  amount: 'amount',
  discountPolicy: 'discountPolicy',
  isActive: 'isActive',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  vehicleId: 'vehicleId',
  deletedAt: 'deletedAt',
  period: 'period',
  periodPolicy: 'periodPolicy'
} as const

export type VehicleDiscountScalarFieldEnum = (typeof VehicleDiscountScalarFieldEnum)[keyof typeof VehicleDiscountScalarFieldEnum]


export const VehicleDamageScalarFieldEnum = {
  id: 'id',
  description: 'description',
  title: 'title',
  isRepaired: 'isRepaired',
  severity: 'severity',
  location: 'location',
  estimatedRepairCost: 'estimatedRepairCost',
  images: 'images',
  partId: 'partId',
  vehicleId: 'vehicleId',
  repairedAt: 'repairedAt',
  customerId: 'customerId',
  isActive: 'isActive',
  isDeleted: 'isDeleted',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy'
} as const

export type VehicleDamageScalarFieldEnum = (typeof VehicleDamageScalarFieldEnum)[keyof typeof VehicleDamageScalarFieldEnum]


export const VehiclePartScalarFieldEnum = {
  id: 'id',
  partName: 'partName',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VehiclePartScalarFieldEnum = (typeof VehiclePartScalarFieldEnum)[keyof typeof VehiclePartScalarFieldEnum]


export const FuelPolicyScalarFieldEnum = {
  id: 'id',
  policy: 'policy',
  code: 'code'
} as const

export type FuelPolicyScalarFieldEnum = (typeof FuelPolicyScalarFieldEnum)[keyof typeof FuelPolicyScalarFieldEnum]


export const VehicleServiceLogScalarFieldEnum = {
  id: 'id',
  vehicleId: 'vehicleId',
  serviceId: 'serviceId',
  servicedAt: 'servicedAt',
  notes: 'notes',
  contactId: 'contactId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  updatedBy: 'updatedBy',
  scheduledServiceId: 'scheduledServiceId',
  damageId: 'damageId',
  cost: 'cost',
  documents: 'documents'
} as const

export type VehicleServiceLogScalarFieldEnum = (typeof VehicleServiceLogScalarFieldEnum)[keyof typeof VehicleServiceLogScalarFieldEnum]


export const VehicleMaintenanceScalarFieldEnum = {
  id: 'id',
  vehicleId: 'vehicleId',
  vendorId: 'vendorId',
  startDate: 'startDate',
  endDate: 'endDate',
  cost: 'cost',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  createdBy: 'createdBy',
  updatedBy: 'updatedBy',
  isDeleted: 'isDeleted',
  status: 'status',
  tenantId: 'tenantId'
} as const

export type VehicleMaintenanceScalarFieldEnum = (typeof VehicleMaintenanceScalarFieldEnum)[keyof typeof VehicleMaintenanceScalarFieldEnum]


export const VehicleServiceScheduleScalarFieldEnum = {
  id: 'id',
  vehicleId: 'vehicleId',
  serviceId: 'serviceId',
  scheduledDate: 'scheduledDate',
  isCompleted: 'isCompleted'
} as const

export type VehicleServiceScheduleScalarFieldEnum = (typeof VehicleServiceScheduleScalarFieldEnum)[keyof typeof VehicleServiceScheduleScalarFieldEnum]


export const BookingVehicleHistoryScalarFieldEnum = {
  id: 'id',
  bookingId: 'bookingId',
  fromVehicleId: 'fromVehicleId',
  toVehicleId: 'toVehicleId',
  reason: 'reason',
  swappedAt: 'swappedAt',
  swappedBy: 'swappedBy'
} as const

export type BookingVehicleHistoryScalarFieldEnum = (typeof BookingVehicleHistoryScalarFieldEnum)[keyof typeof BookingVehicleHistoryScalarFieldEnum]


export const VehicleEventScalarFieldEnum = {
  id: 'id',
  vehicleId: 'vehicleId',
  event: 'event',
  type: 'type',
  date: 'date',
  notes: 'notes'
} as const

export type VehicleEventScalarFieldEnum = (typeof VehicleEventScalarFieldEnum)[keyof typeof VehicleEventScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'PortType'
 */
export type EnumPortTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PortType'>
    


/**
 * Reference to a field of type 'PortType[]'
 */
export type ListEnumPortTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PortType[]'>
    


/**
 * Reference to a field of type 'CustomerStatus'
 */
export type EnumCustomerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerStatus'>
    


/**
 * Reference to a field of type 'CustomerStatus[]'
 */
export type ListEnumCustomerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerStatus[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'FormType'
 */
export type EnumFormTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormType'>
    


/**
 * Reference to a field of type 'FormType[]'
 */
export type ListEnumFormTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormType[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'RentalAction'
 */
export type EnumRentalActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RentalAction'>
    


/**
 * Reference to a field of type 'RentalAction[]'
 */
export type ListEnumRentalActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RentalAction[]'>
    


/**
 * Reference to a field of type 'NotificationType'
 */
export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


/**
 * Reference to a field of type 'NotificationType[]'
 */
export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


/**
 * Reference to a field of type 'NotificationPriority'
 */
export type EnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority'>
    


/**
 * Reference to a field of type 'NotificationPriority[]'
 */
export type ListEnumNotificationPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationPriority[]'>
    


/**
 * Reference to a field of type 'Agent'
 */
export type EnumAgentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Agent'>
    


/**
 * Reference to a field of type 'Agent[]'
 */
export type ListEnumAgentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Agent[]'>
    


/**
 * Reference to a field of type 'RentalStatus'
 */
export type EnumRentalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RentalStatus'>
    


/**
 * Reference to a field of type 'RentalStatus[]'
 */
export type ListEnumRentalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RentalStatus[]'>
    


/**
 * Reference to a field of type 'DirectionType'
 */
export type EnumDirectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectionType'>
    


/**
 * Reference to a field of type 'DirectionType[]'
 */
export type ListEnumDirectionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DirectionType[]'>
    


/**
 * Reference to a field of type 'VesselType'
 */
export type EnumVesselTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VesselType'>
    


/**
 * Reference to a field of type 'VesselType[]'
 */
export type ListEnumVesselTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VesselType[]'>
    


/**
 * Reference to a field of type 'StatItem'
 */
export type EnumStatItemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatItem'>
    


/**
 * Reference to a field of type 'StatItem[]'
 */
export type ListEnumStatItemFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatItem[]'>
    


/**
 * Reference to a field of type 'BillingPeriod'
 */
export type EnumBillingPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingPeriod'>
    


/**
 * Reference to a field of type 'BillingPeriod[]'
 */
export type ListEnumBillingPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingPeriod[]'>
    


/**
 * Reference to a field of type 'PricePolicy'
 */
export type EnumPricePolicyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricePolicy'>
    


/**
 * Reference to a field of type 'PricePolicy[]'
 */
export type ListEnumPricePolicyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricePolicy[]'>
    


/**
 * Reference to a field of type 'SubscriptionStatus'
 */
export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


/**
 * Reference to a field of type 'SubscriptionStatus[]'
 */
export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


/**
 * Reference to a field of type 'VerificationStatus'
 */
export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


/**
 * Reference to a field of type 'VerificationStatus[]'
 */
export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


/**
 * Reference to a field of type 'TransactionType'
 */
export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


/**
 * Reference to a field of type 'TransactionType[]'
 */
export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'Severity'
 */
export type EnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity'>
    


/**
 * Reference to a field of type 'Severity[]'
 */
export type ListEnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity[]'>
    


/**
 * Reference to a field of type 'DamageLocation'
 */
export type EnumDamageLocationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DamageLocation'>
    


/**
 * Reference to a field of type 'DamageLocation[]'
 */
export type ListEnumDamageLocationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DamageLocation[]'>
    


/**
 * Reference to a field of type 'MaintenanceStatus'
 */
export type EnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus'>
    


/**
 * Reference to a field of type 'MaintenanceStatus[]'
 */
export type ListEnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus[]'>
    


/**
 * Reference to a field of type 'VehicleEventType'
 */
export type EnumVehicleEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleEventType'>
    


/**
 * Reference to a field of type 'VehicleEventType[]'
 */
export type ListEnumVehicleEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleEventType[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}


export type Datasource = {
  url?: string
}
export type Datasources = {
  db?: Datasource
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
   */
  adapter?: runtime.SqlDriverAdapterFactory | null
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  service?: Prisma.ServiceOmit
  chargeType?: Prisma.ChargeTypeOmit
  vehicleBrand?: Prisma.VehicleBrandOmit
  vehicleModel?: Prisma.VehicleModelOmit
  vehicleBodyType?: Prisma.VehicleBodyTypeOmit
  vehicleStatus?: Prisma.VehicleStatusOmit
  fuelType?: Prisma.FuelTypeOmit
  transmission?: Prisma.TransmissionOmit
  vehicleFeature?: Prisma.VehicleFeatureOmit
  wheelDrive?: Prisma.WheelDriveOmit
  invoiceSequence?: Prisma.InvoiceSequenceOmit
  country?: Prisma.CountryOmit
  state?: Prisma.StateOmit
  village?: Prisma.VillageOmit
  maintenanceService?: Prisma.MaintenanceServiceOmit
  documentType?: Prisma.DocumentTypeOmit
  presetLocation?: Prisma.PresetLocationOmit
  licenseClass?: Prisma.LicenseClassOmit
  messengerApp?: Prisma.MessengerAppOmit
  equipment?: Prisma.EquipmentOmit
  contactType?: Prisma.ContactTypeOmit
  paymentType?: Prisma.PaymentTypeOmit
  vendorType?: Prisma.VendorTypeOmit
  port?: Prisma.PortOmit
  customer?: Prisma.CustomerOmit
  customerMessengerApp?: Prisma.CustomerMessengerAppOmit
  customerAddress?: Prisma.CustomerAddressOmit
  customerDocument?: Prisma.CustomerDocumentOmit
  driverLicense?: Prisma.DriverLicenseOmit
  customerViolation?: Prisma.CustomerViolationOmit
  rentalAgreement?: Prisma.RentalAgreementOmit
  invoice?: Prisma.InvoiceOmit
  paymentReceipt?: Prisma.PaymentReceiptOmit
  caribbeanCountry?: Prisma.CaribbeanCountryOmit
  shopDMMerchant?: Prisma.ShopDMMerchantOmit
  currency?: Prisma.CurrencyOmit
  tenantCurrencyRate?: Prisma.TenantCurrencyRateOmit
  exchangeRate?: Prisma.ExchangeRateOmit
  form?: Prisma.FormOmit
  formResponse?: Prisma.FormResponseOmit
  rentalActivity?: Prisma.RentalActivityOmit
  tenantNotification?: Prisma.TenantNotificationOmit
  notificationReadStatus?: Prisma.NotificationReadStatusOmit
  appPermission?: Prisma.AppPermissionOmit
  permissionCategory?: Prisma.PermissionCategoryOmit
  rental?: Prisma.RentalOmit
  storefrontBooking?: Prisma.StorefrontBookingOmit
  rentalDriver?: Prisma.RentalDriverOmit
  values?: Prisma.ValuesOmit
  rentalExtra?: Prisma.RentalExtraOmit
  rentalCharge?: Prisma.RentalChargeOmit
  vesselInfo?: Prisma.VesselInfoOmit
  tenantWeeklyStats?: Prisma.TenantWeeklyStatsOmit
  tenantYearlyStats?: Prisma.TenantYearlyStatsOmit
  tenantMonthlyStats?: Prisma.TenantMonthlyStatsOmit
  tenantMonthlyRentalStats?: Prisma.TenantMonthlyRentalStatsOmit
  tenantRatings?: Prisma.TenantRatingsOmit
  siteRatings?: Prisma.SiteRatingsOmit
  subscriptionPlan?: Prisma.SubscriptionPlanOmit
  planFeatures?: Prisma.PlanFeaturesOmit
  planDetails?: Prisma.PlanDetailsOmit
  tenant?: Prisma.TenantOmit
  emailVerification?: Prisma.EmailVerificationOmit
  paymentMethod?: Prisma.PaymentMethodOmit
  address?: Prisma.AddressOmit
  tenantLocation?: Prisma.TenantLocationOmit
  tenantInsurance?: Prisma.TenantInsuranceOmit
  tenantEquipment?: Prisma.TenantEquipmentOmit
  tenantService?: Prisma.TenantServiceOmit
  tenantSubscription?: Prisma.TenantSubscriptionOmit
  tenantContact?: Prisma.TenantContactOmit
  tenantReminders?: Prisma.TenantRemindersOmit
  cancellationPolicy?: Prisma.CancellationPolicyOmit
  latePolicy?: Prisma.LatePolicyOmit
  tenantViolation?: Prisma.TenantViolationOmit
  tenantVendor?: Prisma.TenantVendorOmit
  verificationRequest?: Prisma.VerificationRequestOmit
  transactions?: Prisma.TransactionsOmit
  payment?: Prisma.PaymentOmit
  refund?: Prisma.RefundOmit
  expense?: Prisma.ExpenseOmit
  user?: Prisma.UserOmit
  storefrontUser?: Prisma.StorefrontUserOmit
  adminUser?: Prisma.AdminUserOmit
  userRole?: Prisma.UserRoleOmit
  userRolePermission?: Prisma.UserRolePermissionOmit
  emailTokens?: Prisma.EmailTokensOmit
  vehicle?: Prisma.VehicleOmit
  vehicleDiscount?: Prisma.VehicleDiscountOmit
  vehicleDamage?: Prisma.VehicleDamageOmit
  vehiclePart?: Prisma.VehiclePartOmit
  fuelPolicy?: Prisma.FuelPolicyOmit
  vehicleServiceLog?: Prisma.VehicleServiceLogOmit
  vehicleMaintenance?: Prisma.VehicleMaintenanceOmit
  vehicleServiceSchedule?: Prisma.VehicleServiceScheduleOmit
  bookingVehicleHistory?: Prisma.BookingVehicleHistoryOmit
  vehicleEvent?: Prisma.VehicleEventOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

